<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue之网易云音乐横向菜单的实现]]></title>
    <url>%2F2018%2F06%2F30%2Fhorizontal-menu%2F</url>
    <content type="text"><![CDATA[之前在学习的时候有稍微捣鼓一下网易云音乐，主要是为了学习Vue，巩固基础知识，然后看到这个横向菜单，当然个人也喜欢看球，所以每次看腾讯NBA的时候总是会想这个是这样实现的，于是借助之前还没写完的demo，完成这个横向菜单的实现，废话不多说，先上效果图 从使用虎牙直播横向菜单的体验得到，我们的横向菜单的业务逻辑如下： 滑动菜单，并选择菜单项； 选择某个菜单项，该菜单项居中（去除边界菜单项） 我们的使用的better-scroll这个插件来实现，具体安装请参考BetterScroll 前端DOM结构12345678910111213&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 通过使用插件Vue来调试项目 其中tabs包括菜单项名和它的路由1234567891011121314151617181920212223242526272829303132333435data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, // tab移动的距离 tabWidth: 80 // 每个tab的宽度 &#125; 样式12345678910111213141516171819202122232425.mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box 样式和DOM结构就不详细讲了，具体讲实现吧首先需要计算出这个菜单中所有内容的width，也就是包裹这个菜单的容器；接着初始化better-scroll，并忽略该实例对象的垂直方向的滑动.1234567891011121314151617methods: &#123; _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' // 忽略这个实例对象的垂直滑动事件 &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125; 这里是第二个业务逻辑的思路（应该会有更好的思路，求大佬指点） 我的思路是这样的：每一个菜单项都会有各自的点击移动操作，所以我是根据当前tabs的位置，通过点击事件将tabs移动到它相应的位置，例如，中间菜单项在点击时会移动到居中的位置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125; &#125; 很多时候我们在使用better-scroll的时候，发现这个实例对象已经初始化，但是不能滑动，是因为，Vue是异步更新数据的，所以我们需要异步计算它实际内容的宽度或者高度，Vue提供一个了this.$nextTick()这个hock来实现，这个API是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 官方解释：$nextTick 当生命钩子mounted触发时，初始化better-scroll12345mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;)&#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from 'better-scroll'export default &#123; data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, tabWidth: 80 &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;) &#125;, methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125;, _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>better-scroll</tag>
        <tag>横向菜单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐PC版轮播图的实现]]></title>
    <url>%2F2018%2F06%2F25%2Fnetease-slider%2F</url>
    <content type="text"><![CDATA[最近在刷网易云音乐歌单时发现首页的轮播图很有意思，正好自己想尝试做一个PC版的网易云音乐，于是就是使用Vue去做这个demo，废话少说，我要出招了，接招吧 页面的DOM结构123456789101112131415161718192021&lt;template&gt; &lt;div class="slider-container" ref='slider' :style="sliderStyle" @mouseover="pause()" @mouseout="play()"&gt; &lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Slider-container的样式(Stylus)123456.slider-container width: 100% height: 100% text-align: center padding: 10px 0 position: relative 这个子组件主要分为两块。 轮播图，其中它们的业务逻辑是 自动切换 左右icon切换轮播图 点击前后轮播图切换轮播图 鼠标滑动到轮播图停止轮播，离开后继续轮播 Slider-content的DOM结构123456789&lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt;&lt;/div&gt; Slider-content的样式(Stylus)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.slider-content position: relative width: 100% height: calc(100% - 20px) left: 0% top: 0% margin: 0px padding: 0px background-size: inherit .slider position: absolute margin: 0 padding: 0 top: 0 left: 50% width: 65% height: 100% transition: 500ms all ease-in-out background-color: #fff background-repeat: no-repeat background-position: center background-size: inherit transform: translate3d(-50%,0,-80px) z-index: 1 &amp;:before position: absolute content: "" width: 100% height: 100% top: 0 left: 0 background-color: rgba(0, 0, 0, 0) transition-delay: 100ms!important transition: all 500ms cursor: pointer &amp;.active transform: translate3d(-50%, 0, 0) z-index: 20 &amp;.prev transform: translate3d(-75%, 0, -100px) z-index: 19 &amp;.next transform: translate3d(-25%, 0, -100px) z-index: 18 i width: 17.5% display: none position: absolute top: 40% font-size: 22px color: rgba(255, 255, 255, 0.5) text-shadow: 0 0 24px rgba(0, 0, 0, 0.3) cursor: pointer z-index: 21 &amp;:first-child left: 0 &amp;:last-child right: 0 &amp;:hover i color: rgba(255, 255, 255, 0.8) display: block &amp;.mask .slider &amp;.prev, &amp;.next &amp;:before background-color: rgba(0, 0, 0, 0.50) 底部的dot， 其中它们的业务逻辑是 当前轮播图对应位置的dot高亮 鼠标移动到相应的dot上切换对应位置的轮播图 Dots的DOM结构12345&lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt;&lt;/div&gt; Dots的样式(Stylus)123456789.dots width: 100% height: 20px span display: inline-block width: 20px height: 2px margin: 1px 3px cursor: pointer 上面是页面的DOM结构和表现的实现代码，接下来我们要讲的是连招的实现，小心啦，我要摸眼W + R3了。上面我们讲到轮播图的业务逻辑，接下来，我们就讲讲如何实现的的吧 自动轮播12345678play () &#123; this.pause(); if (this.autoPlay) &#123; this.timer = setInterval(()=&gt;&#123; this.next(); &#125;, this.interval) &#125;&#125; 暂停轮播123pause () &#123; clearInterval(this.timer);&#125; Icon切换轮播图123456next () &#123; this.currentIndex = ++this.currentIndex % this.list.length;&#125;,prev () &#123; this.currentIndex = this.currentIndex === 0 ? this.list.length - 1 : this.currentIndex - 1;&#125;, 前后轮播图的切换轮播图12345678910111213onClick (i) &#123; if (i === this.currentIndex)&#123; this.$emit('sliderClick', i); &#125; else &#123; let currentClickClassName = this.sliderDomList[i].className.split(' ')[1] console.log(currentClickClassName) if (currentClickClassName === 'next') &#123; this.next() &#125; else &#123; this.prev() &#125; &#125;&#125; dots轮播图的切换轮播图这里比较简单，只需要设置它的鼠标事件即可1@mouseover="currentIndex = index" 到这里，基本上我们提出的业务逻辑原理都已经实现了，到时候我会将代码整理完了commit到github上，现在正在整理ing，谢谢。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>网易云音乐</tag>
        <tag>轮播图</tag>
      </tags>
  </entry>
</search>
