<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx + Node + Vue 部署初试]]></title>
    <url>%2F2019%2F02%2F04%2Fnode-vue-nginx%2F</url>
    <content type="text"><![CDATA[趁着爸妈做年夜饭之前，把之前做的笔记贴出来，新的一年到了，祝大家 Nginx + Node + Vue 部署初试知乎 个人博客 Github 日常学习笔记 Nginx 定义 异步框架的 Web服务器，也可以用作反向代理，负载平衡器 , HTTP缓存, 媒体流等的开源软件。它最初是一个旨在实现最高性能和稳定性的Web服务器。除了HTTP服务器功能外，NGINX还可以用作电子邮件（IMAP，POP3和SMTP）的代理服务器以及HTTP，TCP和UDP服务器的反向代理和负载平衡器。 特点 更快 高扩展性, Nginx的模块都是嵌入到二进制文件中执行 高可靠性 低内存消耗 单机支持10万次的并发连接 热部署, master管理进行与work工作进程分离设计，因此具备热部署功能 最自由的BSD许可协议 功能 静态服务（css , js , html, images, videos） SSL 和 TLS SNI支持 HTTP/HTTPS, SMTP, IMAP/POP3 反向代理 FastCGI反向代理 负载均衡 页面缓存（CDN） 支持gzip、expirse 支持 keep-alive 和管道连接 基于 PCRE 的 rewrite 重写模块 带宽限制 基于IP 和名称的虚拟主机服务 支持访问速率、并发限制 反向代理（适用2000WPV、并发连接1W/秒），简单的负载均衡和容错 基于客户端IP 地址和 HTTP 基本认证的访问控制 Mac 安装Nginx12345678// 推荐使用`brew`, 安装`homebrew`/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"// Homebrew 安装 Nginx brew install nginx// Mac 下 Nginx的目录cd /usr/local/etc/nginxll -alvim nginx.conf homebrew详见 Nginx 参数列表 配置参数属性 解释说明 参数列表 user 设置nginx服务的系统使用用户 nobody(注意：此处用户如果比启动Nginx的用户权限低，你需要使用当前用户重启Nginx)nginx -s stop 关闭nginx-&gt; nginx 启动-&gt; `ps aux grep nginx`查看启动用户 worker_processes 开启的线程数 一般与服务器核数保持一致 error_log 定位全局错误日志文件 错误日志定义等级，[ debug \ info notice \ warn \ error \ crit ]，debug输出最多，crir输出最少 pid 指定进程id的存储文件位置 worker_rlimit_nofile 指定一个nginx进程打开的最多文件描述符数目，受系统进程的最大打开文件数量限制 events 包含Nginx中所有处理连接的设置 http Nginx http处理的所有核心特性 Event 配置参数属性 解释说明 参数列表 worker_connections 定义每个进程的最大连接数,受系统进程的最大打开文件数量限制 单个后台worker process进程的最大并发链接数 （最大连接数= worker_processes worker_connections）在反向代理环境下：最大连接数 = worker_processes worker_connections / 4 use 工作进程数 [ epoll \ /dev/poll \ poll \ eventport \ kqueue \ select \ rtsig ] multi_accept 一个新连接通知后接受尽可能多的连接 on / off accept_mutex 开启或者禁用使用互斥锁来打开sockets on / off Event Use支持的事件模型 Events详见 HTTP 配置参数属性 解释说明 参数列表 include 主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度，DNS主配置文件中的zonerfc1912,acl基本上都是用include语句 default_type 核心模块指令 默认设置为二进制流，也就是当文件类型未定义时使用这种方式 log_format 日志格式的设定 日志格式的名称，可自行设置，后面引用 access_log 引用日志 引用log_format设置的名称 keepalive_timeout 设置客户端连接保存活动的超时时间 0是无限制 sendfile 开启高效文件传输模式 on / off tcp_nopush 开启防止网络阻塞 on / off tcp_nodelay 开启防止网络阻塞 on / off upstream 负载均衡 server Nginx的server虚拟主机配置 Upstream 配置参数属性 解释说明 轮询（默认） 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况 ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 url_hash（第三方） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 weight 默认为1.weight越大，负载的权重就越大。 Nginx Upstream状态例如： 12345upstream news &#123; server 127.0.0.1:9527 backup; server 127.0.0.1:9527 weight=1 max_fails=2 fail_timeout=3; ...&#125; 配置参数属性 解释说明 backup 预留的备份服务器 down 当前的server暂时不参与负载均衡 fail_timeout 经过max_fails 失败后，服务暂停的时间 max_conns 限制最大的接收的连接数 max_fails 允许请求失败的次数 use location：在server中添加 123456proxy_pass http://127.0.0.1:9527;// 因为我的API接口是这个，such as /api/profile// location 具体匹配规则详见后面location ~ /api/ &#123; proxy_pass http://127.0.0.1:9527;&#125; Server 配置参数属性 解释说明 参数列表 listen 监听端口 http -&gt; 80 / https -&gt; 443 server_name 设置主机域名 localhost charset 设置访问的语言编码 access_log 设置虚拟主机访问日志的存放路径及日志的格式 location 设置虚拟主机的基本信息 Location 配置参数属性 解释说明 参数列表 root 设置虚拟主机的网站根目录 Vue项目的根目录/Users/rainy/Desktop/MyWork/Work/cloudwiz-website/dist index 设置虚拟主机默认访问的网页 index.html index.htm proxy 通过不同协议将请求从NGINX传递到代理服务器 =: 开头表示精确匹配，如 api 中只匹配根目录结尾的请求，后面不能带任何字符串. ^~ :开头表示uri以某个常规字符串开头，不是正则匹配. ~: 开头表示区分大小写的正则匹配. ~*: 开头表示不区分大小写的正则匹配. / : 通用匹配, 如果没有其它匹配,任何请求都会匹配到. 匹配优先级(高到低) location = location 完整路径 location ^~ 路径 location ~,~* 正则顺序 location 部分起始路径 / 详见Location配置 Reverse Proxy当NGINX代理请求时，它会将请求发送到指定的代理服务器，获取响应并将其发送回客户端。可以使用指定的协议将请求代理到HTTP服务器（另一个NGINX服务器或任何其他服务器）或非HTTP服务器（可以运行使用特定框架（如PHP或Python）开发的应用程序）。 12345678910111213location / some / path / &#123; proxy_pass http://www.example.com:8080; proxy_set_header Host $ host ; proxy_set_header X-Real-IP $ remote_addr ; // 禁用特定位置的缓冲 proxy_buffering off ; proxy_buffers 16 4k ; proxy_buffer_size 2k ; proxy_bind 127.0.0.2 ; // IP地址也可以用变量指定&#125; 将请求传递给非HTTP代理服务器，**_pass应使用相应的指令： fastcgi_pass 将请求传递给FastCGI服务器 uwsgi_pass 将请求传递给uwsgi服务器 scgi_pass 将请求传递给SCGI服务器 memcached_pass 将请求传递给memcached服务器 配置参数属性 解释说明 参数列 proxy_pass 将请求传递给HTTP代理服务器 proxy_set_header 传递请求标头 默认情况下，NGINX在代理请求中重新定义两个头字段“Host”和“Connection”，并删除其值为空字符串的头字段。“Host”设置为$proxy_host变量，“Connection”设置为close。 proxy_buffering 负责启用和禁用缓冲 on / off proxy_buffers 请求分配的缓冲区的大小和数量 proxy_buffer_size 代理服务器的响应的第一部分存储在单独的缓冲区大小 通常包含一个相对较小的响应头，并且可以比其余响应的缓冲区小。 proxy_bind 接受来自特定IP网络或IP地址范围的连接 指定proxy_bind必要网络接口的指令和IP地址 详见Proxy 全局变量Global Variable 变量名 变量含义 $args 请求中的参数 $content_length HTTP请求信息里的Content-Length $content_type 请求信息里的Content-Type $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $http_cookie cookie 信息 $http_referer 引用地址 $http_user_agent 客户端代理信息 $remote_addr 客户端地址 $remote_port 客户端端口号 $remote_user 客户端用户名，认证用 $request_method 请求的方法，比如GET、POST等 $request_uri 完整的原始请求URI（带参数） $scheme 请求方案，http或https $server_addr 接受请求的服务器的地址,如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费); $server_protocol 请求的协议版本，HTTP/1.0或HTTP/1.1 $uri 请求中的当前URI, $uri在请求处理期间 ，值可能会发生变化，例如在执行内部重定向或使用索引文件时 全局变量详见Alphabetical index of variables 修改 http server中的配置 启动Nginx 12nginxps -ef | grep nginx 重启Nginx 1nginx -s reload 关闭Nginx 1nginx -s stop 因为我已经启动了，所以就重启一下Nginx即可 Linux安装NginxLinux安装 常见的Linux命令 使用pstree查看当前服务器启动的进程 1pstree 查找Nginx的位置 1ps -aux | grep nginx 进入nginx的目录 然后配置nginx.conf文件即可 Docker安装Nginx 查找 Docker Hub 上的 nginx镜像 1docker search nginx 拉取官方镜像 1docker pull nginx 查看当前镜像 1docker images nginx Server Tree123456789101112tree -C -L 3 -I '*node_modules*'├── server│ ├── app.js│ ├── db│ │ ├── db.js│ │ └── newsSql.js│ ├── package-lock.json│ ├── package.json│ └── routers│ ├── news.js│ └── router.js Node Server12npm initnpm install express mysql body-parser -S app.js 123456789101112131415const express = require('express')const bodyParser = require('body-parser')const app = express()const router = require('./routers/router')const PORT = 9527app.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use(router)app.listen(PORT, () =&gt; &#123; console.log(`Listen port at $&#123;PORT&#125;`)&#125;) db.js -&gt; Mysql配置 123456789module.exports = &#123; mysql: &#123; host: 'localhost', user: 'root', password: 'xxxx', database: 'test', port: '3306' &#125;&#125; router.js 12345678910111213141516171819202122232425const express = require('express')const router = express.Router()const news = require('./news')router.get('/api/news/queryAll', (req, res, next) =&gt; &#123; news.queryAll(req, res, next)&#125;)router.get('/api/news/query', (req, res, next) =&gt; &#123; news.queryById(req, res, next)&#125;)router.post('/api/news/add', (req, res, next) =&gt; &#123; news.add(req, res, next)&#125;)router.post('/api/news/update', (req, res, next) =&gt; &#123; news.update(req, res, next)&#125;)router.delete('/api/news/deleteNews', (req, res, next) =&gt; &#123; news.deleteNews(req, res, next)&#125;)module.exports = router newSql.js 1234567891011121314151617module.exports = &#123; createNews: `CREATE TABLE news ( id int(255) NOT NULL AUTO_INCREMENT, type varchar(255) CHARACTER SET utf8 NOT NULL, title varchar(255) CHARACTER SET utf8 NOT NULL, description varchar(255) CHARACTER SET utf8 NOT NULL, occur_time varchar(255) CHARACTER SET utf8 NOT NULL, url varchar(255) NOT NULL, newsImg varchar(255) NOT NULL, PRIMARY KEY (id) )`, queryAll: 'SELECT * FROM news', queryById: 'SELECT * FROM news WHERE id = ?', add: 'INSERT INTO news (type, title, description, occur_time, url, newsImg) VALUES (?, ?, ?, ?, ?, ?)', update: 'UPDATE news SET type = ?, title = ?, description = ?, occur_time = ?, url = ?, newsImg = ? WHERE id = ?', delete: 'DELETE FROM news WHERE id = ?'&#125; news.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const mysql = require('mysql')const db = require('../db/db')const $newsSql = require('../db/newsSql')let pool = mysql.createPool(db.mysql)let queryAll = (req, res, next) =&gt; &#123; pool.getConnection((error, connect) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; connect.query($newsSql.queryAll, (error, data) =&gt; &#123; if (error) &#123; throw error &#125; res.json(&#123; code: '200', msg: 'success', data &#125;) connect.release() &#125;) &#125; &#125;)&#125;let queryById = (req, res, next) =&gt; &#123; let id = +req.query.id pool.getConnection((error, connect) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; connect.query($newsSql.queryById, id, (error, data) =&gt; &#123; if (error) &#123; throw error &#125; res.json(&#123; code: '200', msg: 'success', data &#125;) connect.release() &#125;) &#125; &#125;)&#125;let add = (req, res, next) =&gt; &#123; let rb = req.body let params = [rb.type, rb.title, rb.description, rb.occur_time, rb.url, rb.newsImg] pool.getConnection((error, connect) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; connect.query($newsSql.add, params, (error, data) =&gt; &#123; if (error) &#123; throw error &#125; res.json(&#123; code: '200', msg: 'success' &#125;) connect.release() &#125;) &#125; &#125;)&#125;let update = (req, res, next) =&gt; &#123; let rb = req.body let params = [rb.type, rb.title, rb.description, rb.occur_time, rb.url, rb.newsImg, rb.id] pool.getConnection((error, connect) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; connect.query($newsSql.update, [...params], (error, data) =&gt; &#123; if (error) &#123; throw error &#125; res.json(&#123; code: '200', msg: 'success' &#125;) connect.release() &#125;) &#125; &#125;)&#125;let deleteNews = (req, res, next) =&gt; &#123; let id = +req.query.id pool.getConnection((error, connect) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; connect.query($newsSql.delete, id, (error, data) =&gt; &#123; if (error) &#123; throw error &#125; res.json(&#123; code: '200', msg: 'success' &#125;) connect.release() &#125;) &#125; &#125;)&#125;module.exports = &#123; queryAll, queryById, add, update, deleteNews&#125; Vue配置代理以及使用api config/index.js 修改proxyTable 12345678910111213module.exports = &#123; dev: &#123; proxyTable: &#123; '/api': &#123; target: 'http://127.0.0.1:9527', changeOrigin: true, pathRewrite: &#123; '^/api': '/api' &#125; &#125; &#125; &#125;&#125; 使用axios调用接口 123456789101112131415import axios from &apos;axios&apos;export default &#123; created () &#123; this._getAllNews() &#125;, methods: &#123; _getAllNews () &#123; axios.get(&apos;/api/news/queryAll&apos;).then(res =&gt; &#123; if (+res.data.code === SCC_CODE) &#123; this.news = res.data.data &#125; &#125;) &#125; &#125;&#125; Vue build打包1npm run build 因为我的Server端是Express写的，启动Server需要使用Node，所以我们需要在服务器上安装Node. Linux安装Node 8.x1234567891011# Using Ubuntucurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_8.x | bash -apt-get install -y nodejs# Using Centoscurl -sL https://rpm.nodesource.com/setup_8.x | bash -yum install -y nodejs 具体安装各版本的Node详见 启动Node 此处我之前的命令执行错误，所以我需要kill这个进程 1nohup node website/server/app.js &amp; nohup:可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。 无论是否将 nohup命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 到这里，我们的Web，Node Server ，Nginx都已经配置并启动好了，我们只需要到浏览器输入你的服务器IP:8080即可. Nginx众多概念详见官方词汇表 什么是应用交付？ 什么是应用交付控制器（ADC）？ 什么是应用程序服务器与Web服务器？ 什么是缓存？ 什么是云负载平衡？ 什么是聚类？ 什么是DevOps？ 什么是分布式拒绝服务（DDoS）？ 什么是DNS负载平衡？ 什么是全局服务器负载平衡？ 什么是高可用性？ 什么是HTTP？ 什么是HTTP / 2？ 什么是混合负载均衡？ 什么是第4层负载均衡？ 什么是第7层负载平衡？ 什么是负载平衡？ 什么是媒体服务器？ 什么是微服务？ 什么是网络负载均衡器？ 什么是NGINX？ 什么是渐进式下载？ 什么是反向代理服务器？ 什么是反向代理与负载均衡器？ 什么是循环负载平衡？ 什么是面向服务的体系结构（SOA）？ 什么是会话持久性？ 什么是SSL负载均衡器？ 什么是Web加速？ 什么是Web服务器？]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Node</tag>
        <tag>Nginx</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+React-Route+Antd+Recharts+Excel(获取Excel数据，绘制Charts)]]></title>
    <url>%2F2019%2F01%2F01%2Fcharts%2F</url>
    <content type="text"><![CDATA[转眼间2018年就过去了，来到的2019新的一年，在这里，祝大家新年快乐。知乎个人博客GithubDemoRepo 开发缘由：因为一个很重要的朋友需要绘制一些Charts，但是嫌弃手绘太慢，因此这次放假写了这个小东西当前进度：简单的Demo Charts展示，包括AreaChart, BarChart, ComposedChart, LineChart, PieChart测试文件：src/common/files/info.xlsx附上 Recharts React-Route 先上两张照片吧 1、版本 2、创建项目因为公司使用的 react+antd+ts, 虽然antd前两天搞了个圣诞惊吓，但是毋庸置疑，这个组件库做的确实很好啊，我不怕被喷，辩证一分为二，不能因为别人犯一点的错误，就否认人家吧，废话不多说，还是讲本文的主题吧首先先安装create-react-app 12npm i -g create-react-appcreate-react-app Charts --scripts-version=react-scripts-ts-antd 然后安装react-route-dom和recharts1234yarn add react-route-domornpm i react-route-dom --savenpm i recharts --save 因为TS检查较为严格，所以，我对TS有一些我自己需要rules的配置tslint.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; "extends": ["tslint:recommended", "tslint-react", "tslint-config-prettier"], "linterOptions": &#123; "exclude": [ "config/**/*.js", "node_modules/**/*.ts", "coverage/lcov-report/*.js" ] &#125;, "rules": &#123; "no-string-throw": true, "no-unused-expression": false, "no-unused-variable": false, "no-use-before-declare": false, "no-duplicate-variable": false, "curly": true, "class-name": true, "triple-equals": [true, "allow-null-check"], "comment-format": [false, "check-space"], "eofline": true, "forin": false, "indent": [true, "spaces", 2], "label-position": true, "max-line-length": [true, 150], "member-access": false, "no-arg": true, "no-bitwise": false, "no-console": [true, "debug", "info", "time", "timeEnd", "trace" ], "no-construct": true, "no-debugger": true, "no-empty": false, "no-eval": true, "no-inferrable-types": true, "no-shadowed-variable": false, "no-string-literal": false, "no-switch-case-fall-through": false, "no-trailing-whitespace": true, "no-var-keyword": false, "object-literal-sort-keys": false, "one-line": [true, "check-open-brace", "check-catch", "check-else" ], "radix": false, "typedef-whitespace": [true, &#123; "call-signature": "nospace", "index-signature": "nospace", "parameter": "nospace", "property-declaration": "nospace", "variable-declaration": "nospace" &#125;], "variable-name": [true, "ban-keywords"], "whitespace": [true, "check-branch", "check-decl", "check-type", "check-preblock" ], "ordered-imports": false, "jsx-no-lambda": false, "interface-name": [true, "never-prefix"], "prefer-const": false &#125;&#125; TS初试 React-Route 4.x提供给我们使用的都是以组件形式存在的。我们使用的时候就像我们以前使用组件那样使用就行了，详见React-Route官方文档。 菜单栏，我觉得日后可能还会增加其他的Charts，所以我将菜单通过配置文件来控制，增加复用性。 SideMenu.tsx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';import classnames from 'classnames';import moment from 'moment';import './index.scss';import &#123; menus &#125; from './menus';import &#123; Layout, Menu, Icon &#125; from 'antd';import Timer from 'src/components/Timer/Timer';const &#123; Header, Footer, Sider, Content &#125; = Layout;const &#123; SubMenu &#125; = Menu;interface SideMenuProps &#123; children?: any;&#125;export default class SideMenu extends Component&lt;SideMenuProps, any&gt; &#123; public state = &#123; collapsed: false, selectedKeys: [menus[0].key], &#125;; public toggle = () =&gt; &#123; this.setState(&#123; collapsed: !this.state.collapsed &#125;); &#125;; render() &#123; const &#123; collapsed, selectedKeys, &#125; = this.state return ( &lt;Layout className="side-menu"&gt; &lt;Sider trigger=&#123;null&#125; collapsible=&#123;true&#125; collapsed=&#123;collapsed&#125;&gt; &lt;div className="logo"&gt; &lt;img src=&#123;require('src/common/images/logo.png')&#125; /&gt; &lt;a href="https://github.com/Rain120/charts" target="_blank"&gt; &lt;span className=&#123;classnames("title")&#125;&gt;&lt;Icon type="github" /&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href="https://www.zhihu.com/people/yan-yang-nian-hua-120/activities" target="_blank"&gt; &lt;span className=&#123;classnames("title")&#125;&gt;&lt;Icon type="zhihu" /&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;Menu theme="dark" mode="inline" defaultSelectedKeys=&#123;selectedKeys&#125;&gt; &#123; menus &amp;&amp; menus.map(menu =&gt; ( menu.children ? ( &lt;SubMenu key=&#123;menu.key&#125; title=&#123;&lt;span&gt;&lt;Icon type=&#123;menu.icon&#125; /&gt;&lt;span&gt;&#123;menu.text&#125;&lt;/span&gt;&lt;/span&gt;&#125;&gt; &#123; menu.children.map(item =&gt; ( &lt;Menu.Item key=&#123;item.key&#125;&gt; &lt;Link to=&#123;item.path&#125;&gt;&#123;item.text&#125;&lt;/Link&gt; &lt;/Menu.Item&gt; )) &#125; &lt;/SubMenu&gt; ) : ( &lt;Menu.Item key=&#123;menu.key&#125;&gt; &lt;Link to=&#123;menu.path&#125; style=&#123;&#123; overflow: 'hidden' &#125;&#125;&gt;&lt;Icon type=&#123;menu.icon&#125; /&gt;&#123;menu.text&#125;&lt;/Link&gt; &lt;/Menu.Item&gt; ) )) &#125; &lt;/Menu&gt; &lt;/Sider&gt; &lt;Layout className="r-content"&gt; &lt;Header&gt; &lt;Icon className="trigger" type=&#123;collapsed ? 'menu-unfold' : 'menu-fold'&#125; onClick=&#123;this.toggle&#125; /&gt; &lt;Timer timerStyle="timer" /&gt; &lt;/Header&gt; &lt;Content style=&#123;&#123; margin: '1rem', padding: '1rem', background: '#fff', minHeight: '25rem', &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/Content&gt; &lt;Footer style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt; ©&#123;moment().format('YYYY')&#125; Created by Rainy &lt;/Footer&gt; &lt;/Layout&gt; &lt;/Layout&gt; ); &#125;&#125; Menu.ts 123456789101112131415161718192021222324252627/* * @Author: Rainy * @Github: https://github.com/Rain120 * @Date: 2018-12-30 15:43:12 * @LastEditTime: 2018-12-31 13:28:04 */export const menus = [ &#123; key: 'menu-0', icon: 'bar-chart', text: 'Charts Demo Show', path: '/', &#125;, &#123; key: 'menu-1', icon: 'dashboard', text: 'ReCharts', children: [ &#123; key: '1', text: 'Charts Drawer', path: '/charts/charts-drawer' &#125;, ] &#125;] as any; 获取Excel的数据是通过使用大佬的xlsx插件来实现的，详见XLSX官网。1npm i xlsx -S 因为这次项目没有后端，所以其实我们对Excel文件的解析是在upload之前完成的1234567891011121314151617181920212223242526public beforeUpload = (file: any, fileList: any) =&gt; &#123; var rABS = true; const f = fileList[0]; var reader = new FileReader(); reader.onload = (e: any) =&gt; &#123; let data: any = e.target.result; if (!rABS) &#123; data = new Uint8Array(data); &#125; var workbook = XLSX.read(data, &#123; type: rABS ? 'binary' : 'array' &#125;); // more sheet workbook.SheetNames.map(item =&gt; &#123; var worksheet = workbook.Sheets[item]; var jsonArr = XLSX.utils.sheet_to_json(worksheet, &#123; header: 1 &#125;); this.handleImpotedJson(jsonArr); &#125;) &#125;; if (rABS) &#123; reader.readAsBinaryString(f); &#125; else &#123; reader.readAsArrayBuffer(f); &#125; return false;&#125; upload config 123456789101112131415161718192021const props = &#123; accept: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', name: 'file', headers: &#123; authorization: 'authorization-text', &#125;, multiple: false, action: '', beforeUpload: (file, fileList) =&gt; this.beforeUpload(file, fileList), onChange(info) &#123; const status = info.file.status; if (status !== 'uploading') &#123; console.log(info.file, info.fileList); &#125; if (status === 'done') &#123; message.success(`$&#123;info.file.name&#125; file uploaded successfully.`); &#125; else if (status === 'error') &#123; message.error(`$&#123;info.file.name&#125; file upload failed.`); &#125; &#125;, &#125;; Charts组件因为使用的Charts比较多，所以使用recharts提供的组件ResponsiveContainer为了使得这些Charts不够缩放的影响。但是当前做的这些Charts大部分都是相同的结构，所以相同的部分应该抽离出来。 因为其他的Charts都差不多，这里我只说一下LineCharts 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react';import WrapperCharts from './WrapperCharts';import './index.scss';import &#123; Line, Legend, Tooltip, XAxis, YAxis, CartesianGrid, LineChart, Label,&#125; from "recharts";export const COLOR_LISTS = ['#8884d8', '#cf6868', '#3fb549', '#a6d41f', '#8ad4d8', '#cfdd68', '#354449', '#a75d1f'];interface LineChartsProps &#123; data?: any; names?: any;&#125;export default class LineCharts extends Component&lt;LineChartsProps, any&gt; &#123; render() &#123; const &#123; data, names &#125; = this.props; return ( &lt;WrapperCharts class_name="line-charts"&gt; &lt;LineChart data=&#123;data&#125;&gt; &lt;CartesianGrid /&gt; &#123; names &amp;&amp; &lt;XAxis dataKey=&#123;names[0].dataKey&#125; name=&#123;names[0].name&#125; /&gt; &#125; &lt;YAxis /&gt; &lt;Tooltip /&gt; &lt;Legend /&gt; &#123; names &amp;&amp; names.slice(1).map((item, index) =&gt; ( &lt;Line type="monotone" dataKey=&#123;item.dataKey&#125; key=&#123;index&#125; name=&#123;item.name&#125; stroke=&#123;COLOR_LISTS[index]&#125; /&gt; )) &#125; &lt;Label /&gt; &lt;/LineChart&gt; &lt;/WrapperCharts&gt; ) &#125;&#125; github page deploy 1npm i -g gh-pages package.json配置12"predeploy": "yarn run build","deploy": "gh-pages -d build" 部署1yarn run deploy 引入图片 以上就是这两天做的小东西，写的和讲的都很潦草，请看管轻喷。]]></content>
      <tags>
        <tag>Antd</tag>
        <tag>Recharts</tag>
        <tag>Excel</tag>
        <tag>React Github Page部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目从无到有的部署上Github page]]></title>
    <url>%2F2018%2F10%2F19%2Fvue-deploy-githug-page%2F</url>
    <content type="text"><![CDATA[准备工作 Nodejs安装 Node官网下载 建议安装在非系统盘的英文目录下 Node环境配置 新建文件夹 — node_cache 和 node_global(npm install -g package-name) 创建完文件后，需要更改 npmrc 中的 perfix 和 cache12npm config set prefix "E:\Program Files (x86)\Nodejs\node_global"npm config set cache "E:\Program Files (x86)\Nodejs\node_cache" 你需要替换你的安装目录 Vue-cli安装12npm run -g vuevue -V 创建Vue项目1vue init webpack project-name 修改Vue项目配置 config/index.js –&gt; build –&gt; assetsPublicPath –&gt; / –&gt; ./ build/webpack.prod.conf.js –&gt; new HtmlWebpackPlugin –&gt; removeAttributeQuotes –&gt; true –&gt; false.gitignore –&gt; 注释/dist/ 项目打包1npm run build 项目测试12在使用http-server前，需要安装 npm i -g http-serverhttp-server ./dist 创建Github项目 本地Vue项目Push到Github官网1234567891011git init git add . git commit -m 'init vue project' git remote add origin git@github.com:Rain120/demo.git git pull origin master --allow-unrelated-histories git push -u origin master Github Setting – 配置Github page SettingsGithub PagesSave Setting最后可以在 https://rain120.github.io/demo/dist/，可以看到部署上线的效果（这个仓库我会在演示完后删掉，请自行测试）]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Github Pages</tag>
        <tag>Vue部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript之正则表达式的学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2Fjavascript-regexp%2F</url>
    <content type="text"><![CDATA[小白正则表达式入门学习：正则表达式30分钟入门教程 正则表达式Regular Expression是一种文本模式。它描述了一种字符串匹配的模式pattern，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。我们将正则表达式分为几个部分记下笔记，便于理解与使用。 1. 元字符我们在 MDN-Regular_Expression 上得知，正则表达式会有一些特殊字符，也叫作元字符。如下表示： 字符 含义 英语记忆或者个人记忆方法 匹配字符 \b 匹配一个单词边界，也就是指单词和空格间的位置。一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了） blank \B 匹配非单词边界。一个字符串的开始和结尾都被认为不是“字”字符，或者空字符串 Blank，b与B相反 \d 匹配一个数字字符。等价于 [0-9] digit \D 匹配一个非数字字符。等价于 [^0-9] Digit，d与D相反 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 space \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 Space, s与S相反 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’ word \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’ Word，w与W相反 匹配特殊字符 \t 匹配一个制表符 (\x09)。 Table \n 匹配一个换行符 (\x09A)。 New line \f 匹配一个换页符 (\x09C)。 Page break#Form feed \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 Vertical table \r 匹配一个回车符 (\x09D)。 Return \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。 反斜杠也可以将其后的特殊字符，转义为字面量,当需要使用\时也需要将其转义 x &VerticalLine; y 匹配 x 或 y 或运算 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置 开始 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置 结束 匹配内容次数 * 匹配前面的子表达式零次或多次 `{0, n} + 匹配前面的子表达式一次或多次 {1, n} ? 匹配前面的子表达式零次或一次 {0, 1} 匹配分组 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，JS使用 $0…$9 属性获取匹配结果 匹配括号内部的正则表达式结果 [xy] 字符集合,匹配所包含的任意一个字符 匹配[]内部的内容,即x y [^xy] 字符集合,匹配所包含的任意一个字符 匹配[]内部的内容,即不是x y的任意一个字符 [a-z] 字符集合,匹配所包含的任意一个字符 匹配[]内部的内容,即a-z之间任意一个字符 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符 匹配[]内部的内容,即不是a-z之间任意一个字符 {n} n 是一个非负整数。匹配确定的 n 次 匹配连续出现n次的字符 {n,} n 是一个非负整数。至少匹配n 次 匹配至少出现n次的字符 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次 匹配出现 [n, m]次字符 优先级：正则表达式从左到右进行计算，并遵循优先级顺序 下面我们讲上述元字符一个一个的测试. 不过，在测试之前，我们先了解两个正则表达式的方法，test() 和 exec()。 元字符\b与\B 从上面结果得知，b匹配的是单词的边界，B匹配的是非单词的边界 元字符\d与\D 元字符\s与\S 元字符\w与\W 2. 参数 参数列表 含义 英语记忆或者个人记忆方法 i 忽略大小写 ignoreCase g 全文查找出现的所有匹配字符 global m 多行查找 multiline y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志 sticky 当然，上面这几种匹配规则可以结合使用，例如/ig或者/gi都是全文查找、忽略大小写 3. 方法 方法 含义 匹配返回值 未匹配返回值 test() 测试是否匹配的RegExp方法 true false exec() 执行查找匹配的RegExp方法 数组 null match(pattern) 执行查找匹配的String方法 数组 null search(pattern) 测试匹配的String方法 返回匹配到的位置索引 -1 replace(pattern, obj &VerticalLine;&VerticalLine; callback) 执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串 一个新的字符串 null split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法 返回一个数组 null 下面我们讲上述方法一个一个的详细介绍。 test(str)param：strresult:匹配成功： 如果正则表达式与指定的字符串匹配 ，返回true 匹配失败： false exec(str)param：strresult:匹配成功： exec() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。 匹配失败： 如果匹配失败，exec() 方法返回 null。 对象 属性/索引 描述 result [0] 匹配的全部字符串 [1], …[n] 括号中的分组捕获 index 匹配到的字符位于原始字符串的基于0的索引值 input 原始字符串 regexp lastIndex 下一次匹配开始的位置 ignoreCase 是否使用了 “i” 标记使正则匹配忽略大小写 global 是否使用了 “g” 标记来进行全局的匹配 true multiline 是否使用了 “m” 标记使正则工作在多行模式（也就是，^ 和 $ 可以匹配字符串中每一行的开始和结束（行是由 \n 或 \r 分割的），而不只是整个输入字符串的最开始和最末尾处。） source 正则匹配的字符串 Back to test char match(pattern)search(pattern)replace(pattern, obj &VerticalLine;&VerticalLine; callback)split未完待续ing]]></content>
      <tags>
        <tag>前端学习</tag>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之你可能会遇到的编程题(1)]]></title>
    <url>%2F2018%2F08%2F21%2FInterview-programming-01%2F</url>
    <content type="text"><![CDATA[“开源（open source）”这个词，指的是事物规划为可以公开访问的，因此人们可以修改并分享。 作为一个从大型同性社交网站GitHub / Rain120上学习成长的一个前端菜鸟的我，深受大佬的感染，也希望有机会能够给同样是菜鸟的你们提供帮助，在我学习之余，留下了之前学习遇到的、网上看到的、笔试面试遇到的一些编程的解法，还请各位大佬手下留情，多多提携、指点我等菜鸟。 欢迎各位大佬留下更加简单的写法，谢谢！！ 代码仓库: Web-Study 废话不多说，先上题吧。 1、关系型数组转换成树形结构对象(拼多多2018前端笔试真题 / 依图面试)关系型数组12345var obj = [ &#123; id:3, parent:2 &#125;, &#123; id:1, parent:null &#125;, &#123; id:2, parent:1 &#125;,] 期望结果：1234567891011121314o = &#123; obj: &#123; id: 1, parent: null, child: &#123; id: 2, parent: 1, child: &#123; id: ,3, parent: 2 &#125; &#125; &#125;&#125; 思路： 先找到它的根元素，根据id和parent来判断它们之间的关系 实现源码：12345678910111213141516function treeObj(obj) &#123; obj.map(item =&gt; &#123; if (item.parent !== null) &#123; obj.map(o =&gt; &#123; if (item.parent === o.id) &#123; if (!o.child) &#123; o.child = []; &#125; o.child.push(item); o.child = o.child; &#125; &#125;); &#125; &#125;); return obj.filter(item =&gt; item.parent === null)[0]&#125; 解法2：(知乎评论区提供的方法)1234function treeObj(obj) &#123; return obj.sort((a, b) =&gt; b.parent - a.parent) .reduce((acc, cur) =&gt; (acc ? &#123; ...cur, child: acc &#125; : cur));&#125; 实现效果： 2、请用 javascript 实现一个函数 parseUrl(url)，将一段 url字符串解析为 Object。(西洋汇笔试)1parseUrl("http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title"); 期望结果：12345678910&#123; protocol: "http", host: "www.xiyanghui.com", path: "/product/list", params: &#123; id: "12345", sort: "discount" &#125;, hash: "title"&#125; 思路： 首先我们需要了解一下URL这个概念。 URL(统一资源定位符)（或称统一资源定位器/定位地址、URL地址等，英语：Uniform Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。 这里，我补充一点，各位不仅需要了解 URL，还需要了解 URI。 URI：统一资源标识符（英语：Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。 URI包括了URL和URN。 下图展示了两个 URI 例子及它们的组成部分。 URL一般包括协议、域名、端口、query、params等，我们在传入参数时是字符串，我们需要将它转换成URL，可以通过创建一个a标签来将字符串 转换成URL 。 实现源码：12345678910111213141516171819202122232425262728function parseUrl(url) &#123; var a = document.createElement('a'); a.href = url; return &#123; source: url, protocol: a.protocol.replace(':',''), host: a.hostname, port: a.port, query: a.search, params: (() =&gt; &#123; var ret = &#123;&#125;, querys = []; var searchQuery = a.search.replace(/^\?/,'').split('&amp;'); for ( var i = 0;i &lt; searchQuery.length; i++) &#123; if (searchQuery[i]) &#123; querys = searchQuery[i].split('='); ret[querys[0]] = querys[1]; &#125; &#125; return ret; &#125;)(), file: (a.pathname.match(/\/([^\/?#]+)$/i) || [,''])[1], hash: a.hash.replace('#',''), path: a.pathname.replace(/^([^\/])/,'/$1'), relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [,''])[1], segments: a.pathname.replace(/^\//,'').split('/') &#125;; &#125; parseUrl("http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title"); 实现效果： 3、数组元素的排列组合问题1[1, 2, 3] 期望结果： 全排列：1[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] 思路： 每次取数组中的一个数，然后将剩余的数，依次加入到该数的组合数组中 实现代码：123456789101112131415161718192021222324function Permutations (target, size, origin) &#123; var _arr = [] function getArrange(target, nums, ret) &#123; if (nums === 1) &#123; for (var i = 0; i &lt; target.length; i++) &#123; var tmp = ret.slice(); tmp.push(target[i]); _arr.push(tmp); &#125; &#125; else &#123; nums -= 1; for (var i = 0; i &lt; target.length; i++) &#123; var tmp = ret.slice(); var newTarget = target.slice(); tmp.push(target[i]); newTarget.splice(i, 1); getArrange(newTarget, nums, tmp); &#125; &#125; &#125; getArrange(target, size, origin); return _arr;&#125;Permutations([1, 2, 3], 2, []) 实现效果： 1[1, 2, 3, 4] 排列组合：1[[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] 思路： 取一个数，加入到数组中，接着再取一个数加入数组，直到需要的num为0。 实现代码：123456789101112131415161718function Permutations (arr, nums) &#123; var ret = []; function getRet(origin, target, nums) &#123; if (nums === 0) &#123; ret[ret.length] = origin; return; &#125; for (var i = 0; i &lt;= target.length - nums; i++) &#123; var tmp = origin.slice(); tmp.push(target[i]); getRet(tmp, target.slice(i + 1), nums - 1); &#125; &#125; getRet([], arr, nums); return ret;&#125;Permutations([1, 2, 3, 4], 3) 实现效果： 4、JS如何判断一组数字是否连续(百词斩笔试题)12// 当出现连续数字的时候以‘-’输出[1, 2, 3, 4, 6, 8, 9, 10] 期望结果：1["1-4", 6, "8-10"] 原理： 判断前后数字是否相差为1，如果是则加入同一个数组 实现代码： 判断是否连续：1234567891011121314var arrange = function(arr)&#123; var result = [],temp = []; arr.sort(function(source, dest)&#123; return source - dest; &#125;).concat(Infinity).reduce(function(source, dest)&#123; temp.push(source); if(dest-source &gt; 1)&#123; result.push(temp); temp = []; &#125; return dest; &#125;); return result;&#125;; 实现效果： 格式化实现：1234567891011121314var formatarr = function(arr) &#123; var newArr = [] var arr1 = arrange(arr) for (var i in arr1) &#123; var str = ''; if (arr1[i].length &gt; 1) &#123; str = arr1[i][0] + '-' + arr1[i][arr1[i].length - 1]; newArr.push(str) &#125; else &#123; newArr.push(arr1[i][0]); &#125; &#125; return newArr;&#125; 实现效果： 5、创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄。(详见我的另一篇文章前端面试问题之面向对象类)实现代码： 父类：1234567function People(name,age)&#123; this.name=name; this.age=age; this.say=function()&#123; console.log("我的名字是:"+this.name+"我今年"+this.age+"岁！"); &#125;;&#125; 原型继承：(原型链相关问题请看我的另一篇文章前端面试之原型链问题)1234567function Child(name, age)&#123; this.name = name; this.age = age;&#125;Child.prototype = new People();var child = new Child('Rainy', 20);child.say() 实现效果： 构造函数继承1234567function Child(name, age)&#123; People.call(this) this.name = name; this.age = age;&#125;var child = new Child('Rainy', 20);child.say() 实现效果: 组合继承：12345678function Child(name, age)&#123; People.call(this); this.name = name; this.age = age;&#125;Child.prototype = People.prototype;var child = new Child('Rainy', 20);child.say() 实现效果： 组合继承优化：123456789function Child(name, age)&#123; People.call(this); this.name = name; this.age = age;&#125;Child.prototype = Object.create(People.prototype);Child.prototype.constructor = Child;var child = new Child('Rainy', 20);child.say() 实现效果： 未完待续]]></content>
      <tags>
        <tag>前端笔试、面试题</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现左右菜单联动实现]]></title>
    <url>%2F2018%2F08%2F11%2Fcascade-menu%2F</url>
    <content type="text"><![CDATA[源码传送门：Rain120/vue-study 根据掘金评论需求，更新了数据接口并修复了一些问题之前在外卖软件上看到这个左右联动的效果，觉得很有意思，所以就尝试使用Vue来实现，将这个联动抽离成为一个单独的组件，废话少说，先来一张效果图。 这个组件分为两个部分，1、左菜单；2、右菜单。 动态数据结构12345678910111213141516171819202122232425menus: [ &#123; name: '菜单1', data: [ &#123; name: '1.1' &#125;, &#123; name: '1.2' &#125;, &#123; name: '1.3' &#125;, &#123; name: '1.4' &#125;, &#123; name: '1.5' &#125;, &#123; name: '1.6' &#125; ] &#125;] data数据是用户自定义增加一些内容，并渲染DOM 左菜单的DOM结构123456789101112131415161718&lt;scroll class="left-menu" :data="menus" ref="leftMenu"&gt; &lt;div class="left-menu-container"&gt; &lt;ul&gt; &lt;li class="left-item" ref="leftItem" :class="&#123;'current': currentIndex === index&#125;" @click="selectLeft(index, $event)" v-for="(menu, index) in menus" :key="index"&gt; &lt;p class="text"&gt;&#123;&#123;menu.name&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/scroll&gt; 右菜单的DOM结构 12345678910111213141516171819202122&lt;scroll class="right-menu" :data="menus" ref="rightMenu" @scroll="scrollHeight" :listenScroll="true" :probeType="3"&gt; &lt;div class="right-menu-container"&gt; &lt;ul&gt; &lt;li class="right-item" ref="rightItem" v-for="(menu, i) in menus" :key="i"&gt; &lt;div class="title"&gt;&#123;&#123;menu.name&#125;&#125;&lt;/div&gt; &lt;ul&gt; &lt;li v-for="(item, j) in menu.data" :key="j"&gt; &lt;div class="data-wrapper"&gt; &lt;div class="data"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/scroll&gt; 这里是为了做demo，所以在数据上只是单纯捏造。 当然因为这是个子组件，我们将通过父组件传递props，所以定义props123456789props: &#123; menus: &#123; required: true, type: Array, default () &#123; return [] &#125; &#125; &#125;, 在这个业务场景中，我们的实现方式是根据右边菜单滚动的高度来计算左边菜单的位置，当然左边菜单也可以通过点击来确定右边菜单需要滚动多高的距离，那么我们如何获得该容器滚动的距离呢？之前一直在使用better-scroll，通过阅读文档，我们知道它有有scroll事件，我们可以通过监听这个事件来获取滚动的pos123456if (this.listenScroll) &#123; let me = this this.scroll.on('scroll', (pos) =&gt; &#123; me.$emit('scroll', pos) &#125;)&#125; 所以我们在右边菜单的scroll组件上监听scroll事件1@scroll="scrollHeight" method1234scrollHeight (pos) &#123; console.log(pos); this.scrollY = Math.abs(Math.round(pos.y))&#125;, 我们将监听得到的pos打出来看看 我们可以看到控制台打出了当前滚动的pos信息，因为在移动端开发时，坐标轴和我们数学中的坐标轴相反，所以上滑时y轴的值是负数 所以我们要得到每一块li的高度,我们可以通过拿到他们的DOM12345678910 _calculateHeight() &#123; let lis = this.$refs.rightItem; let height = 0 this.rightHeight.push(height) Array.prototype.slice.call(lis).forEach(li =&gt; &#123; height += li.clientHeight this.rightHeight.push(height) &#125;)console.log(this.rightHeight)&#125; 我们在created这个hook之后调用这个计算高度的函数12345678910 _calculateHeight() &#123; let lis = this.$refs.rightItem; let height = 0 this.rightHeight.push(height) Array.prototype.slice.call(lis).forEach(li =&gt; &#123; height += li.clientHeight this.rightHeight.push(height) &#125;) console.log(this.rightHeight)&#125; 当用户在滚动时，我们需要计算当前滚动距离实在那个区间内，并拿到他的index 123456789computed: &#123; currentIndex () &#123; const &#123; scrollY, rightHeight &#125; = this const index = rightHeight.findIndex((height, index) =&gt; &#123; return scrollY &gt;= rightHeight[index] &amp;&amp; scrollY &lt; rightHeight[index + 1] &#125;) return index &gt; 0 ? index : 0 &#125;&#125; 所以当前应该是左边菜单index = 1的菜单项active以上是左边菜单根据右边菜单的滑动联动的实现，用户也可以通过点击左边菜单来实现右边菜单的联动，此时，我们给菜单项加上click事件1@click="selectLeft(index, $event)" 这里加上$event是为了区分原生点击事件还是better-scroll派发的事件12345678selectLeft (index, event) &#123; if (!event._constructed) &#123; return &#125; let rightItem = this.$refs.rightItem let el = rightItem[index] this.$refs.rightMenu.scrollToElement(el, 300)&#125;, 使用1&lt;cascad-menu :menus="menus"&gt;&lt;/cascad-menu&gt; 到这里我们就基本上完成了这些需求了]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>左右联动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript尝试]]></title>
    <url>%2F2018%2F07%2F21%2Ftypescript-essay%2F</url>
    <content type="text"><![CDATA[最近入职，发现公司使用到typescript，所以就在此留下一个笔记，方便自己和大家一起学习。 TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。 大家日常学习可以去TS Playground测试一些代码 那我们就来开始学习吧！ 基本类型的定义在使用TS之前，我们定义的JavaScript变量都是弱类型语言，它不像C，Java这种，会在编译的时候对变量进行类型检查，所以有的时候会出现意想不到的Bug。 使用TS我们可以处理很简单的数据类型： Boolean类型12345// booleanlet isEmpty: boolean = true;// Type '"false"' is not assignable to type 'boolean'.isEmpty = 'false'; isEmpty = false; Number类型12345// numberlet num: number = 10;// Type '"1"' is not assignable to type 'number'.num = '1';num = 1; String类型1234// stringlet github_name: string;github_name = 120;github_name = 'Rain120'; Array类型123456789101112// arraylet arr: number[];arr = [1, '2', 3];arr = [1, 2, 3];let arr1: Array&lt;number&gt;;arr1 = [1, '2', 3];arr1 = [1, 2, 3];let fe: string[];fe = [1, 2, 3]; // TSfe = ['Vue', 'React', 'Angular']; 不确定什么属性12345678// anylet type_con: any;type_con = [];type_con = &#123;&#125;;type_con = 1;type_con = '2';type_con = true;type_con.func(); Void123//voidlet test_void: void = null;test_void = 1; Function定义12345678910111213141516function vo(): void &#123; console.log('这是一个返回值为void的函数');&#125;function vo1(): void &#123; console.log('这是一个返回值为void的函数'); return '';&#125;function str(): string &#123; console.log('这是一个返回值为string的函数');&#125;function str1(): string &#123; console.log('这是一个返回值为string的函数'); return 'string';&#125; 当我们在使用函数的时候，有些时候会使用到函数参数默认，或者可选参数，那么在TS中如何写呢？123456function game(name: string, rank?: string, score: number = 0): string &#123; return `$&#123;name&#125; $&#123;rank&#125; $&#123;score&#125;`&#125;console.log(game('rainy', 'difficult', 10000));console.log(game('rainy', 'difficult'));console.log(game('rainy')); Class类123456789101112131415161718192021222324252627282930313233class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; greet() &#123; console.log(`Hello, $&#123;this.name&#125;`); &#125;&#125;class Student extends Person &#123; name: string; age: number; constructor(name: string, age: number) &#123; super(name); this.age = age; &#125; greet() &#123; console.log(`Hello, My name is $&#123;this.name&#125; and I'm $&#123;this.age&#125;`); &#125; study() &#123; console.log(`$&#123;this.name&#125;, you should go to study.`) &#125;&#125;let p = new Person('Rain120');console.log('p:', p.name)p.greet()let stu = new Student('Rain', 21);console.log('stu:', stu.name, stu.age);stu.greet();stu.study(); 我们在学习面向对象的语言，C++和Java时候知道类的属性和方法是有修饰符的，他们决定了外部是否能够访问类中的属性、方法，当用户为定义是，属性和方法默认都是public 属性，其中还有protected 和private 属性。当你使用private 修饰符定义成属性或者方法时，如果你需要让其他使用者使用这个属性时，你可以定义一个public 的方法，之后用户只能通过这个API接口来获取属性值或者方法的结果，例如：123456789101112class Person &#123; private name: string; constructor(name: string) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;let p = new Person('Rain120');console.log('person name:', p.name)console.log('person name:', p.getName()) 虽然这里报错了，但是编译结果却是可以的应为TS在转换成JS语言后，并没有真的将name编译成私有的属性，TypeScript的核心原则之一是对值所具有的结构进行类型检查，它的作用只是提示开发者。 protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问, 这就不详细讲解这些了，大家可以去学习下Java或者C++的类，感受一下。 接口（Interface）在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。这句话太官方了，我自己理解的就是它定义了一些你自己约定的参数类型。 工作中，我们使用到的是React+Typescript，所以，我把我日常写法拿出来。123456789101112interface SystemsProps &#123; systems: any&#125;export class Systems extends React.Component&lt;SystemsProps, any&gt; ... render() &#123; const &#123; systems &#125; = this.props return ( &lt;div&gt;&#123;systems.name&#125;&lt;/div&gt; ) &#125;&#125; 当然，从C++中学到接口也是可以继承的，例如：123456789interface Color&#123; color: string;&#125;interface Car extends Color&#123; price: number;&#125;let car = &lt;Car&gt;&#123;&#125;;car.color = "white";car.price = 10000000; 泛型在像C++和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 其实我们之前有用到泛型，只是没有说到这个概念。1let arr: Array&lt;number&gt; = [1, 2, 3, 4]; 这是一个最简答你的泛型，定义了一个number类型的数组，下面我写一个复杂点的泛型：1234567891011121314151617class Fruit &#123; name: string; price: number; constructor(name: string, price: number) &#123; this.name = name; this.price = price; &#125; sold() &#123; console.log(`$&#123;this.name&#125; sold $$&#123;this.price&#125;`) &#125;&#125;let fruit: Array&lt;Fruit&gt; = []fruit[0] = new Fruit('apple', 8)fruit[1] = new Fruit('banana', 5)fruit[2] = new Fruit('lemon', 10)console.log(fruit) 这个泛型是一个Fruit类型的数组，这个数组的子元素全是Fruit类型，当我们定义一个其他类型是，例如1fruit[3] = &#123; name: 'watermelon', price: 2 &#125; 类型推断机制12let num = 10;num = 'str'; 我们平常在使用变量赋值的时候，这样写是没有问题，但是使用TS类型检查后，它会根据用户第一次定义或者赋值的类型来推断该变量的类型，这就是TS的类型推断机制。 迭代器这里我们讲下我们常见的几种的迭代器，包括for-in, for-of，用来跟forEach对比，直接上代码，我们从代码来分析它们之间的不同1234567891011121314151617181920let arr: any = ['a','b','c'];arr.type = 'array'arr.forEach((item, index) =&gt; &#123; console.log('forEach', index, item, arr[index]);&#125;)for (let i in arr) &#123; console.log('for-in', i, arr[i]);&#125;let obj = &#123; 'a': 'I\'m a', 'b': 'I\'m b', 'c': 'I\'m c'&#125;for (let i of arr) &#123; console.log('for-of', i, obj[i]);&#125; 从结果上来看， forEach：只是常见的for循环，它不会遍历该对象的属性值；for-in：迭代的是对象的键（key）的列表，它会遍历对象的属性；for-of：迭代对象的键对应的值（value），它也不会遍历对象的属性。 模块这个地方熟悉CommonJS的都会知道export（导出）， import（导入），所以这里就不详细讲了，直接跳过 最后讲一下，tsconfig.json的配置，详见tsconfig.json1234567891011121314151617181920212223242526272829303132333435363738&#123; "compilerOptions": &#123; "moduleResolution": "node", "outDir": ./dist", // 生成的所有文件放在dist目录下 "target": "es5", // 将JavaScript代码降级到低版本ECMAScript 5 "lib": ["es6", "dom"], "rootDir": "app/", //仅用来控制输出的目录结构。 "jsx": "react", // 用于指定按照何种方式生成jsx代码，可选react和preserve。 "module": "esnext", // 用于指定模块的代码生成规则，可以使用 commonjs 、 amd 、 umd 、 system 、 es6 、 es2015 、 none 这些选项。 "declaration": false, // 是否需要生成定义文件d.ts，设置为true，则生成 "allowJs": true, // 接受JavaScript做为输入 "allowSyntheticDefaultImports": true, // 置为true时，则允许从没有默认导出的模块中默认导入(也就是不做检查)。 "inlineSourceMap": false, // 是否需要将sourceMap文件生成到js文件中，设置为true，则生成到js文件中。 "sourceMap": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 "noEmitOnError": false, // 设置为true时，如果遇到了错误，就不再输出 "emitDecoratorMetadata": false, // 设置为true，则使用元数据特性 "experimentalDecorators": true, // 设置为true，则支持ES7的装饰器特性 "noImplicitReturns": true, // 会防止你忘记在函数末尾返回值 "noImplicitThis": false, "noImplicitUseStrict": false, // 当设置为true时，编译输出时不会调用'use strict'指令（也就是不生成use strict） "noImplicitAny": false, // 如果编译器无法根据变量的用途推断出变量的类型，它就会悄悄的把变量类型默认为 any。 "noUnusedLocals": false, "baseUrl": "app", "paths": &#123; "app": ["app"] &#125; &#125;, // 包括app下的所有.ts（对应js文件）, .tsx（对应jsx文件）文件 "include": [ "app/**/*.ts", "app/**/*.tsx" ], // 忽略node_modules下所有的文件 "exclude": [ "node_modules", ... //其他要忽略的文件或者正则表达式表示 ]&#125;]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office 2016专业版激活教程]]></title>
    <url>%2F2018%2F07%2F21%2FCrack-Office%2F</url>
    <content type="text"><![CDATA[传送门：office 2016专业版激活教程 office 2016专业版激活教程 进入office激活教程中选择自己的版本进入相应的文件夹，下载相应的bat.txt 将bat.txt改为bat.cmd，默认是没有显示文件扩展名的，打开方式如下 管理员身份运行 运行ing 运行完成 激活完成]]></content>
      <categories>
        <category>Office2016 激活office</category>
      </categories>
      <tags>
        <tag>Office 2016</tag>
        <tag>激活office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome DevTools调试（前后端小白必备招式）-- 第一招（设备模式+元素面板）]]></title>
    <url>%2F2018%2F07%2F04%2FChrome-Debug-01%2F</url>
    <content type="text"><![CDATA[转眼就毕业了，大家都各奔前程，同学有走读研，有走后端，有走测试，前端就我一个人了，所以肩负起那些走南闯北的同学的希望，解决他们遇到的前端Bug问题，然后发现好多同学都不会借助浏览器调试找出问题的所在，超级心累 因此留下这篇日志，为了方便我前端小白的那些同学更快解决问题。 此文只介绍Google的Chrome DevTools，其他浏览器大同小异，请自己探索。 官方链接 Chrome 开发者工具是一套内置于Google Chrome中的Web开发和调试工具，可用来对网站进行迭代、调试和分析。 打开Chrome 开发者工具 在页面元素上右键点击，选择 “检查” 使用 快捷键 Ctrl+Shift+I (Windows) 或 Cmd+Opt+I (Mac) 我就拿我的知乎主页来介绍吧，开发者工具打开之后 我们先了解一下开发者工具的面板介绍： 设备模式 当你的项目是移动适配时，你可以根据这个选项设置你的设备类型，包括IPhone6/7/X等设备 元素面板 你可以选择开发者工具中的左上角的那个Button，或者Windows下使用快捷键Shift+Ctrl+C 检查应用到元素的样式 与元素匹配的选择器的关联样式。 User Agent 样式表清晰标记，并且在网页上经常被 CSS 替换。 已被级联规则替换的规则将显示为带删除线的文本。 继承的样式将在“Inherited from ”标头下显示为一组。点击标头中的 DOM 节点可以导航到其在 DOM 树视图中的位置。 （CSS 2.1 属性表显示了哪些属性是可以继承的。） 灰色的条目不是已定义的规则，而是在运行时计算的规则。 如图示，当你在点击该Button时，鼠标在页面上选择任意元素，Element中会自动对齐到相应的位置，那么我们接着讲元素的其他操作 比如，我们想知道页面上这个提问按钮的颜色是什么，我想改变，但是不知道什么颜色好看呀，我可以在页面上边看效果，边确认自己的想法 取色器。请参阅取色器了解更多信息。 当前颜色。当前值的可视表示。 当前值。当前颜色的十六进制、RGBA 或 HSL 表示。 调色板。请参阅调色板了解更多信息。 着色和阴影选择器。 色调选择器。 不透明度选择器。 颜色值选择器。点击可以在 RGBA、HSL 和十六进制之间切换。 调色板选择器。点击可以选择不同的模板。 接下来，我们讲讲如何查找类名及其样式，并在页面上修改 比如，我们要找页面上一个叫做UserAvatar的类名，然后在页面上查看他的样式，并进行一些样式的修改 你可以实时的修改HTML元素和CSS样式，当然这些浏览器也会有相应的提示。 HTML元素右击可以修改相对应的属性值 接下来就是见名知意，大家可以自己尝试下其他的功能。 在你选择到你要查看的元素后，你可以在开发者工具中看到你选择HTML，包括类名，然后你可以看到该元素类的样式 使用 Computed 窗格检查和编辑当前元素的框模型参数，该元素是在计算后的表现（包括margin，border，padding，这里需要理解一下盒子模型）， 框模型中的所有值均可修改，只需点击它们即可。 在 Styles 窗格中，点击您修改的文件。DevTools 会将您带到 Sources 面板，很多时候你的代码都是被压缩的状态，你可以点击左下角的{}将其进行格式化 添加、启用和停用 CSS 类 我们接着来看这个提问这个Button，点击 .cls 按钮可以查看与当前选定元素关联的所有 CSS 类。 从这里，您可以执行以下操作： 启用或停用当前与元素关联的类。 向元素添加新类。 添加或移除动态样式（伪类） 有的时候，我们需要查看一些伪类或者动态元素样式在触发之后的状态，例如a标签hover之后的状态,例如，我们将页面中&lt;a class=&quot;AppHeader-navItem&quot; href=&quot;//www.zhihu.com/&quot;&gt;首页&lt;/a&gt;在触发hover之后的颜色和字体更改为color:red;font-size:20px; 从图示可知，我们在选择hover之后，之前灰色的样式变成正常转态，也就是这部分样式生效了，或者右击该元素选择进行下列操作也可以实现 Styles 窗格提供了一个用于向样式规则添加 color 和 background-color 声明的快捷方式。样式规则的右下角有一个由三个点组成的图标。您需要将鼠标悬停到样式规则上才能看到这个图标。这5个图标可以通过提示得知它们的作用 第一招，关于设备模式以及元素面板的招式，基本上已经学完了，大家可以尝试一下，我们第二招再见]]></content>
      <categories>
        <category>Chrome DevTools</category>
      </categories>
      <tags>
        <tag>前端调试技巧</tag>
        <tag>Chrome DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery + dataTable + Bootstrap + 完整逻辑实现表格的增删改查]]></title>
    <url>%2F2018%2F07%2F03%2FdataTable%2F</url>
    <content type="text"><![CDATA[最近在做毕设，同学在做前端页面的时候使用到JQuery、DataTable和Bootstrap这些控件，然后自己又在刷题的时候遇到一个这个demo的实现，于是就自己去官网文档上学习了一下，尝试实现这个demo 官方文档：DataTable Demo代码：Demo代码 效果如下图示： 顶部button DOM结构：123456789101112// 页面上的三个button，增删改&lt;div class="btn-group operation"&gt; &lt;button id="btn_add" type="button" class="btn bg-primary"&gt; &lt;span class="glyphicon glyphicon-plus" aria-hidden="true"&gt;&lt;/span&gt;新增 &lt;/button&gt; &lt;button id="btn_edit" type="button" class="btn bg-info"&gt; &lt;span class="glyphicon glyphicon-pencil" aria-hidden="true"&gt;&lt;/span&gt;修改 &lt;/button&gt; &lt;button id="btn_delete" type="button" class="btn btn-success"&gt; &lt;span class="glyphicon glyphicon-remove" aria-hidden="true"&gt;&lt;/span&gt;删除 &lt;/button&gt;&lt;/div&gt; 这里的Modal框的实现是借助Bootstrap模态框来实现的 添加图书 Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="addBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;添加图书&lt;/h4&gt; &lt;/div&gt; &lt;div id="addBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="bookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelAdd" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="addBooksInfo" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 修改图书内容Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="editBookInfo" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;修改图书内容&lt;/h4&gt; &lt;/div&gt; &lt;div id="editBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="editBookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelEdit" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="saveEdit" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 删除Modal框的实现：1234567891011121314&lt;div class="modal fade" id="deleteBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;确认要删除吗？&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="delete" type="button" class="btn btn-danger" data-dismiss="modal"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 表格的实现：12345678910111213&lt;table id="books" class="table table-striped table-bordered row-border hover order-column" cellspacing="0" width="100%"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;ISBN&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 使用到一些简单的自定义样式：12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .content &#123; margin: 50px auto; border: 1px solid #ccc; &#125; .operation &#123; margin: 10px; &#125; .operation &gt; button &#123; margin: 10px; &#125; #books_length &#123; float: left; margin-left: 20px; &#125; #books_filter &#123; float: right; margin-right: 20px; &#125; #books &#123; margin: 5px; &#125; .center-block &#123; display: block; width: 21%; margin: auto; &#125;&lt;/style&gt; 其中，dataTable有三种数据获取方式，数组，JSON和Ajax请求数据例如数组数据：1var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] 其实官网很多小例子，大家可以参考学习dataTables中文网 以上都是页面的DOM结构的实现，接下来，我们讲讲JS代码实现逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;script&gt; var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] var titles = ['书名', '作者', '价格', '出版社', 'ISBN'] $(function () &#123; var table = $('#books').DataTable(&#123; data: data, "pagingType": "full_numbers", "bSort": true, // 国际化 "language": &#123; "sProcessing": "处理中...", "sLengthMenu": "显示 _MENU_ 项结果", "sZeroRecords": "没有匹配结果", "sInfo": "显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项", "sInfoEmpty": "显示第 0 至 0 项结果，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": &#123; "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页" &#125;, // 排序方式 "oAria": &#123; "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" &#125; &#125;, "columnDefs": [&#123; "searchable": false, "orderable": true, "targets": 0 &#125;], "order": [[1, 'asc']] &#125;); table.on('order.dt search.dt', function() &#123; table.column(0, &#123; search: 'applied', order: 'applied' &#125;).nodes().each(function(cell, i) &#123; cell.innerHTML = i + 1; &#125;); &#125;).draw(); $('#books tbody').on('click', 'tr', function () &#123; if ( $(this).hasClass('selected') ) &#123; $(this).removeClass('selected'); &#125; else &#123; table.$('tr.selected').removeClass('selected'); $(this).addClass('selected'); &#125; &#125;); // 取消添加 $("#cancelAdd").on('click', function() &#123; console.log('cancelAdd'); $("#addBookModal").find('input').val('') &#125;) // 添加图书信息 $("#addBooksInfo").on('click', function() &#123; console.log('addBooksInfo'); if (data.length) &#123; if ($("#addBookModal").find('input').val() !== '') &#123; var bookName = $("#bookName").val() var bookAuthor = $("#bookAuthor").val() var bookPrice = $("#bookPrice").val() var bookPublish = $("#bookPublish").val() var bookISBN = $("#bookISBN").val() var addBookInfos = [].concat(bookName, bookAuthor, bookPrice, bookPublish, bookISBN); for (var i = 0; i &lt; addBookInfos.length; i++) &#123; if (addBookInfos[i] === '') &#123; alert(titles[i] + '内容不能为空') &#125; &#125; table.row.add(['', bookName, bookAuthor, bookPrice, bookPublish, bookISBN]).draw(); $("#addBookModal").find('input').val('') &#125; &#125; else &#123; alert('请输入内容') &#125; &#125;) $("#addBooksInfo").click(); $("#btn_add").click(function()&#123; console.log('add'); $("#addBook").modal() &#125;); // 编辑图书 $('#btn_edit').click(function () &#123; console.log('edit'); if (table.rows('.selected').data().length) &#123; $("#editBookInfo").modal() var rowData = table.rows('.selected').data()[0]; var inputs = $("#editBookModal").find('input') for (var i = 0; i &lt; inputs.length; i++) &#123; $(inputs[i]).val(rowData[i + 1]) &#125; &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 保存编辑 $("#saveEdit").click(function() &#123; var editBookName = $("#editBookName").val() var editBookAuthor = $("#editBookAuthor").val() var editBookPrice = $("#editBookPrice").val() var editBookPublish = $("#editBookPublish").val() var editBookISBN = $("#editBookISBN").val() var newRowData = [].concat(editBookName, editBookAuthor, editBookPrice, editBookPublish, editBookISBN); var tds = Array.prototype.slice.call($('.selected td')) for (var i = 0; i &lt; newRowData.length; i++) &#123; if (newRowData[i] !== '') &#123; tds[i + 1].innerHTML = newRowData[i]; &#125; else &#123; alert(titles[i] + '内容不能为空') &#125; &#125; &#125;) // 取消保存 $("#cancelEdit").click(function() &#123; console.log('cancelAdd'); $("#editBookModal").find('input').val('') &#125;) // 删除项目 $('#btn_delete').click(function () &#123; if (table.rows('.selected').data().length) &#123; $("#deleteBook").modal() &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 删除 $('#delete').click(function () &#123; table.row('.selected').remove().draw(false); &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>dataTable</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>Bootstrap</tag>
        <tag>dataTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐横向菜单的实现]]></title>
    <url>%2F2018%2F06%2F30%2Fhorizontal-menu%2F</url>
    <content type="text"><![CDATA[之前在学习的时候有稍微捣鼓一下网易云音乐，主要是为了学习Vue，巩固基础知识，然后看到这个横向菜单，当然个人也喜欢看球，所以每次看腾讯NBA的时候总是会想这个是这样实现的，于是借助之前还没写完的demo，完成这个横向菜单的实现，废话不多说，先上效果图 从使用虎牙直播横向菜单的体验得到，我们的横向菜单的业务逻辑如下： 滑动菜单，并选择菜单项； 选择某个菜单项，该菜单项居中（去除边界菜单项） 我们的使用的better-scroll这个插件来实现，具体安装请参考BetterScroll 前端DOM结构12345678910111213&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 通过使用插件Vue来调试项目 其中tabs包括菜单项名和它的路由1234567891011121314151617181920212223242526272829303132333435data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, // tab移动的距离 tabWidth: 80 // 每个tab的宽度 &#125; 样式12345678910111213141516171819202122232425.mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box 样式和DOM结构就不详细讲了，具体讲实现吧首先需要计算出这个菜单中所有内容的width，也就是包裹这个菜单的容器；接着初始化better-scroll，并忽略该实例对象的垂直方向的滑动.1234567891011121314151617methods: &#123; _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' // 忽略这个实例对象的垂直滑动事件 &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125; 这里是第二个业务逻辑的思路（应该会有更好的思路，求大佬指点） 我的思路是这样的：每一个菜单项都会有各自的点击移动操作，所以我是根据当前tabs的位置，通过点击事件将tabs移动到它相应的位置，例如，中间菜单项在点击时会移动到居中的位置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125; &#125; 很多时候我们在使用better-scroll的时候，发现这个实例对象已经初始化，但是不能滑动，是因为，Vue是异步更新数据的，所以我们需要异步计算它实际内容的宽度或者高度，Vue提供一个了this.$nextTick()这个hock来实现，这个API是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 官方解释：$nextTick 当生命钩子mounted触发时，初始化better-scroll12345mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;)&#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from 'better-scroll'export default &#123; data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, tabWidth: 80 &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;) &#125;, methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125;, _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>better-scroll</tag>
        <tag>网易云音乐</tag>
        <tag>横向菜单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐PC版轮播图的实现]]></title>
    <url>%2F2018%2F06%2F25%2Fnetease-slider%2F</url>
    <content type="text"><![CDATA[最近在刷网易云音乐歌单时发现首页的轮播图很有意思，正好自己想尝试做一个PC版的网易云音乐，于是就是使用Vue去做这个demo，废话少说，我要出招了，接招吧 页面的DOM结构123456789101112131415161718192021&lt;template&gt; &lt;div class="slider-container" ref='slider' :style="sliderStyle" @mouseover="pause()" @mouseout="play()"&gt; &lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Slider-container的样式(Stylus)123456.slider-container width: 100% height: 100% text-align: center padding: 10px 0 position: relative 这个子组件主要分为两块。 轮播图，其中它们的业务逻辑是 自动切换 左右icon切换轮播图 点击前后轮播图切换轮播图 鼠标滑动到轮播图停止轮播，离开后继续轮播 Slider-content的DOM结构123456789&lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt;&lt;/div&gt; Slider-content的样式(Stylus)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.slider-content position: relative width: 100% height: calc(100% - 20px) left: 0% top: 0% margin: 0px padding: 0px background-size: inherit .slider position: absolute margin: 0 padding: 0 top: 0 left: 50% width: 65% height: 100% transition: 500ms all ease-in-out background-color: #fff background-repeat: no-repeat background-position: center background-size: inherit transform: translate3d(-50%,0,-80px) z-index: 1 &amp;:before position: absolute content: "" width: 100% height: 100% top: 0 left: 0 background-color: rgba(0, 0, 0, 0) transition-delay: 100ms!important transition: all 500ms cursor: pointer &amp;.active transform: translate3d(-50%, 0, 0) z-index: 20 &amp;.prev transform: translate3d(-75%, 0, -100px) z-index: 19 &amp;.next transform: translate3d(-25%, 0, -100px) z-index: 18 i width: 17.5% display: none position: absolute top: 40% font-size: 22px color: rgba(255, 255, 255, 0.5) text-shadow: 0 0 24px rgba(0, 0, 0, 0.3) cursor: pointer z-index: 21 &amp;:first-child left: 0 &amp;:last-child right: 0 &amp;:hover i color: rgba(255, 255, 255, 0.8) display: block &amp;.mask .slider &amp;.prev, &amp;.next &amp;:before background-color: rgba(0, 0, 0, 0.50) 底部的dot， 其中它们的业务逻辑是 当前轮播图对应位置的dot高亮 鼠标移动到相应的dot上切换对应位置的轮播图 Dots的DOM结构12345&lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt;&lt;/div&gt; Dots的样式(Stylus)123456789.dots width: 100% height: 20px span display: inline-block width: 20px height: 2px margin: 1px 3px cursor: pointer 上面是页面的DOM结构和表现的实现代码，接下来我们要讲的是连招的实现，小心啦，我要摸眼W + R3了。上面我们讲到轮播图的业务逻辑，接下来，我们就讲讲如何实现的的吧 自动轮播12345678play () &#123; this.pause(); if (this.autoPlay) &#123; this.timer = setInterval(()=&gt;&#123; this.next(); &#125;, this.interval) &#125;&#125; 暂停轮播123pause () &#123; clearInterval(this.timer);&#125; Icon切换轮播图123456next () &#123; this.currentIndex = ++this.currentIndex % this.list.length;&#125;,prev () &#123; this.currentIndex = this.currentIndex === 0 ? this.list.length - 1 : this.currentIndex - 1;&#125;, 前后轮播图的切换轮播图12345678910111213onClick (i) &#123; if (i === this.currentIndex)&#123; this.$emit('sliderClick', i); &#125; else &#123; let currentClickClassName = this.sliderDomList[i].className.split(' ')[1] console.log(currentClickClassName) if (currentClickClassName === 'next') &#123; this.next() &#125; else &#123; this.prev() &#125; &#125;&#125; dots轮播图的切换轮播图 这里比较简单，只需要设置它的鼠标事件即可1@mouseover="currentIndex = index" 代码传送门：Vue网易云音乐轮播图的实现到这里，基本上我们提出的业务逻辑原理都已经实现了，到时候我会将代码整理完了commit到github上，现在正在整理ing，谢谢。 代码传送门：Vue网易云音乐轮播图的实现]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>better-scroll</tag>
        <tag>网易云音乐</tag>
        <tag>轮播图</tag>
      </tags>
  </entry>
</search>
