<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jquery + dataTable + Bootstrap + 完整逻辑实现表格的增删改查]]></title>
    <url>%2F2018%2F07%2F03%2FdataTable%2F</url>
    <content type="text"><![CDATA[最近在做毕设，同学在做前端页面的时候使用到JQuery、DataTable和Bootstrap这些控件，然后自己又在刷题的时候遇到一个这个demo的实现，于是就自己去官网文档上学习了一下，尝试实现这个demo 官方文档：DataTable Demo代码：Demo代码 效果如下图示： 顶部button DOM结构：123456789101112// 页面上的三个button，增删改&lt;div class="btn-group operation"&gt; &lt;button id="btn_add" type="button" class="btn bg-primary"&gt; &lt;span class="glyphicon glyphicon-plus" aria-hidden="true"&gt;&lt;/span&gt;新增 &lt;/button&gt; &lt;button id="btn_edit" type="button" class="btn bg-info"&gt; &lt;span class="glyphicon glyphicon-pencil" aria-hidden="true"&gt;&lt;/span&gt;修改 &lt;/button&gt; &lt;button id="btn_delete" type="button" class="btn btn-success"&gt; &lt;span class="glyphicon glyphicon-remove" aria-hidden="true"&gt;&lt;/span&gt;删除 &lt;/button&gt;&lt;/div&gt; 这里的Modal框的实现是借助Bootstrap模态框来实现的 添加图书 Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="addBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;添加图书&lt;/h4&gt; &lt;/div&gt; &lt;div id="addBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="bookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelAdd" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="addBooksInfo" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 修改图书内容Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="editBookInfo" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;修改图书内容&lt;/h4&gt; &lt;/div&gt; &lt;div id="editBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="editBookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelEdit" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="saveEdit" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 删除Modal框的实现：1234567891011121314&lt;div class="modal fade" id="deleteBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;确认要删除吗？&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="delete" type="button" class="btn btn-danger" data-dismiss="modal"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 表格的实现：12345678910111213&lt;table id="books" class="table table-striped table-bordered row-border hover order-column" cellspacing="0" width="100%"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;ISBN&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 使用到一些简单的自定义样式：12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .content &#123; margin: 50px auto; border: 1px solid #ccc; &#125; .operation &#123; margin: 10px; &#125; .operation &gt; button &#123; margin: 10px; &#125; #books_length &#123; float: left; margin-left: 20px; &#125; #books_filter &#123; float: right; margin-right: 20px; &#125; #books &#123; margin: 5px; &#125; .center-block &#123; display: block; width: 21%; margin: auto; &#125;&lt;/style&gt; 其中，dataTable有三种数据获取方式，数组，JSON和Ajax请求数据例如数组数据：1var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] 其实官网很多小例子，大家可以参考学习dataTables中文网 以上都是页面的DOM结构的实现，接下来，我们讲讲JS代码实现逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;script&gt; var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] var titles = ['书名', '作者', '价格', '出版社', 'ISBN'] $(function () &#123; var table = $('#books').DataTable(&#123; data: data, "pagingType": "full_numbers", "bSort": true, // 国际化 "language": &#123; "sProcessing": "处理中...", "sLengthMenu": "显示 _MENU_ 项结果", "sZeroRecords": "没有匹配结果", "sInfo": "显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项", "sInfoEmpty": "显示第 0 至 0 项结果，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": &#123; "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页" &#125;, // 排序方式 "oAria": &#123; "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" &#125; &#125;, "columnDefs": [&#123; "searchable": false, "orderable": true, "targets": 0 &#125;], "order": [[1, 'asc']] &#125;); table.on('order.dt search.dt', function() &#123; table.column(0, &#123; search: 'applied', order: 'applied' &#125;).nodes().each(function(cell, i) &#123; cell.innerHTML = i + 1; &#125;); &#125;).draw(); $('#books tbody').on('click', 'tr', function () &#123; if ( $(this).hasClass('selected') ) &#123; $(this).removeClass('selected'); &#125; else &#123; table.$('tr.selected').removeClass('selected'); $(this).addClass('selected'); &#125; &#125;); // 取消添加 $("#cancelAdd").on('click', function() &#123; console.log('cancelAdd'); $("#addBookModal").find('input').val('') &#125;) // 添加图书信息 $("#addBooksInfo").on('click', function() &#123; console.log('addBooksInfo'); if (data.length) &#123; if ($("#addBookModal").find('input').val() !== '') &#123; var bookName = $("#bookName").val() var bookAuthor = $("#bookAuthor").val() var bookPrice = $("#bookPrice").val() var bookPublish = $("#bookPublish").val() var bookISBN = $("#bookISBN").val() var addBookInfos = [].concat(bookName, bookAuthor, bookPrice, bookPublish, bookISBN); for (var i = 0; i &lt; addBookInfos.length; i++) &#123; if (addBookInfos[i] === '') &#123; alert(titles[i] + '内容不能为空') &#125; &#125; table.row.add(['', bookName, bookAuthor, bookPrice, bookPublish, bookISBN]).draw(); $("#addBookModal").find('input').val('') &#125; &#125; else &#123; alert('请输入内容') &#125; &#125;) $("#addBooksInfo").click(); $("#btn_add").click(function()&#123; console.log('add'); $("#addBook").modal() &#125;); // 编辑图书 $('#btn_edit').click(function () &#123; console.log('edit'); if (table.rows('.selected').data().length) &#123; $("#editBookInfo").modal() var rowData = table.rows('.selected').data()[0]; var inputs = $("#editBookModal").find('input') for (var i = 0; i &lt; inputs.length; i++) &#123; $(inputs[i]).val(rowData[i + 1]) &#125; &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 保存编辑 $("#saveEdit").click(function() &#123; var editBookName = $("#editBookName").val() var editBookAuthor = $("#editBookAuthor").val() var editBookPrice = $("#editBookPrice").val() var editBookPublish = $("#editBookPublish").val() var editBookISBN = $("#editBookISBN").val() var newRowData = [].concat(editBookName, editBookAuthor, editBookPrice, editBookPublish, editBookISBN); var tds = Array.prototype.slice.call($('.selected td')) for (var i = 0; i &lt; newRowData.length; i++) &#123; if (newRowData[i] !== '') &#123; tds[i + 1].innerHTML = newRowData[i]; &#125; else &#123; alert(titles[i] + '内容不能为空') &#125; &#125; &#125;) // 取消保存 $("#cancelEdit").click(function() &#123; console.log('cancelAdd'); $("#editBookModal").find('input').val('') &#125;) // 删除项目 $('#btn_delete').click(function () &#123; if (table.rows('.selected').data().length) &#123; $("#deleteBook").modal() &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 删除 $('#delete').click(function () &#123; table.row('.selected').remove().draw(false); &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>dataTable</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>Bootstrap</tag>
        <tag>dataTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐横向菜单的实现]]></title>
    <url>%2F2018%2F06%2F30%2Fhorizontal-menu%2F</url>
    <content type="text"><![CDATA[之前在学习的时候有稍微捣鼓一下网易云音乐，主要是为了学习Vue，巩固基础知识，然后看到这个横向菜单，当然个人也喜欢看球，所以每次看腾讯NBA的时候总是会想这个是这样实现的，于是借助之前还没写完的demo，完成这个横向菜单的实现，废话不多说，先上效果图 从使用虎牙直播横向菜单的体验得到，我们的横向菜单的业务逻辑如下： 滑动菜单，并选择菜单项； 选择某个菜单项，该菜单项居中（去除边界菜单项） 我们的使用的better-scroll这个插件来实现，具体安装请参考BetterScroll 前端DOM结构12345678910111213&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 通过使用插件Vue来调试项目 其中tabs包括菜单项名和它的路由1234567891011121314151617181920212223242526272829303132333435data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, // tab移动的距离 tabWidth: 80 // 每个tab的宽度 &#125; 样式12345678910111213141516171819202122232425.mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box 样式和DOM结构就不详细讲了，具体讲实现吧首先需要计算出这个菜单中所有内容的width，也就是包裹这个菜单的容器；接着初始化better-scroll，并忽略该实例对象的垂直方向的滑动.1234567891011121314151617methods: &#123; _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' // 忽略这个实例对象的垂直滑动事件 &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125; 这里是第二个业务逻辑的思路（应该会有更好的思路，求大佬指点） 我的思路是这样的：每一个菜单项都会有各自的点击移动操作，所以我是根据当前tabs的位置，通过点击事件将tabs移动到它相应的位置，例如，中间菜单项在点击时会移动到居中的位置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125; &#125; 很多时候我们在使用better-scroll的时候，发现这个实例对象已经初始化，但是不能滑动，是因为，Vue是异步更新数据的，所以我们需要异步计算它实际内容的宽度或者高度，Vue提供一个了this.$nextTick()这个hock来实现，这个API是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 官方解释：$nextTick 当生命钩子mounted触发时，初始化better-scroll12345mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;)&#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from 'better-scroll'export default &#123; data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, tabWidth: 80 &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;) &#125;, methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125;, _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>网易云音乐</tag>
        <tag>better-scroll</tag>
        <tag>横向菜单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐PC版轮播图的实现]]></title>
    <url>%2F2018%2F06%2F25%2Fnetease-slider%2F</url>
    <content type="text"><![CDATA[最近在刷网易云音乐歌单时发现首页的轮播图很有意思，正好自己想尝试做一个PC版的网易云音乐，于是就是使用Vue去做这个demo，废话少说，我要出招了，接招吧 页面的DOM结构123456789101112131415161718192021&lt;template&gt; &lt;div class="slider-container" ref='slider' :style="sliderStyle" @mouseover="pause()" @mouseout="play()"&gt; &lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Slider-container的样式(Stylus)123456.slider-container width: 100% height: 100% text-align: center padding: 10px 0 position: relative 这个子组件主要分为两块。 轮播图，其中它们的业务逻辑是 自动切换 左右icon切换轮播图 点击前后轮播图切换轮播图 鼠标滑动到轮播图停止轮播，离开后继续轮播 Slider-content的DOM结构123456789&lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt;&lt;/div&gt; Slider-content的样式(Stylus)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.slider-content position: relative width: 100% height: calc(100% - 20px) left: 0% top: 0% margin: 0px padding: 0px background-size: inherit .slider position: absolute margin: 0 padding: 0 top: 0 left: 50% width: 65% height: 100% transition: 500ms all ease-in-out background-color: #fff background-repeat: no-repeat background-position: center background-size: inherit transform: translate3d(-50%,0,-80px) z-index: 1 &amp;:before position: absolute content: "" width: 100% height: 100% top: 0 left: 0 background-color: rgba(0, 0, 0, 0) transition-delay: 100ms!important transition: all 500ms cursor: pointer &amp;.active transform: translate3d(-50%, 0, 0) z-index: 20 &amp;.prev transform: translate3d(-75%, 0, -100px) z-index: 19 &amp;.next transform: translate3d(-25%, 0, -100px) z-index: 18 i width: 17.5% display: none position: absolute top: 40% font-size: 22px color: rgba(255, 255, 255, 0.5) text-shadow: 0 0 24px rgba(0, 0, 0, 0.3) cursor: pointer z-index: 21 &amp;:first-child left: 0 &amp;:last-child right: 0 &amp;:hover i color: rgba(255, 255, 255, 0.8) display: block &amp;.mask .slider &amp;.prev, &amp;.next &amp;:before background-color: rgba(0, 0, 0, 0.50) 底部的dot， 其中它们的业务逻辑是 当前轮播图对应位置的dot高亮 鼠标移动到相应的dot上切换对应位置的轮播图 Dots的DOM结构12345&lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt;&lt;/div&gt; Dots的样式(Stylus)123456789.dots width: 100% height: 20px span display: inline-block width: 20px height: 2px margin: 1px 3px cursor: pointer 上面是页面的DOM结构和表现的实现代码，接下来我们要讲的是连招的实现，小心啦，我要摸眼W + R3了。上面我们讲到轮播图的业务逻辑，接下来，我们就讲讲如何实现的的吧 自动轮播12345678play () &#123; this.pause(); if (this.autoPlay) &#123; this.timer = setInterval(()=&gt;&#123; this.next(); &#125;, this.interval) &#125;&#125; 暂停轮播123pause () &#123; clearInterval(this.timer);&#125; Icon切换轮播图123456next () &#123; this.currentIndex = ++this.currentIndex % this.list.length;&#125;,prev () &#123; this.currentIndex = this.currentIndex === 0 ? this.list.length - 1 : this.currentIndex - 1;&#125;, 前后轮播图的切换轮播图12345678910111213onClick (i) &#123; if (i === this.currentIndex)&#123; this.$emit('sliderClick', i); &#125; else &#123; let currentClickClassName = this.sliderDomList[i].className.split(' ')[1] console.log(currentClickClassName) if (currentClickClassName === 'next') &#123; this.next() &#125; else &#123; this.prev() &#125; &#125;&#125; dots轮播图的切换轮播图这里比较简单，只需要设置它的鼠标事件即可1@mouseover="currentIndex = index" 到这里，基本上我们提出的业务逻辑原理都已经实现了，到时候我会将代码整理完了commit到github上，现在正在整理ing，谢谢。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>网易云音乐</tag>
        <tag>轮播图</tag>
        <tag>better-scroll</tag>
      </tags>
  </entry>
</search>
