<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Typescript尝试]]></title>
    <url>%2F2018%2F07%2F21%2Ftypescript-essay%2F</url>
    <content type="text"><![CDATA[最近入职，发现公司使用到typescript，所以就在此留下一个笔记，方便自己和大家一起学习。 TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。 大家日常学习可以去TS Playground测试一些代码 那我们就来开始学习吧！ 基本类型的定义在使用TS之前，我们定义的JavaScript变量都是弱类型语言，它不像C，Java这种，会在编译的时候对变量进行类型检查，所以有的时候会出现意想不到的Bug。 使用TS我们可以处理很简单的数据类型： Boolean类型12345// booleanlet isEmpty: boolean = true;// Type '"false"' is not assignable to type 'boolean'.isEmpty = 'false'; isEmpty = false; Number类型12345// numberlet num: number = 10;// Type '"1"' is not assignable to type 'number'.num = '1';num = 1; String类型1234// stringlet github_name: string;github_name = 120;github_name = 'Rain120'; Array类型123456789101112// arraylet arr: number[];arr = [1, '2', 3];arr = [1, 2, 3];let arr1: Array&lt;number&gt;;arr1 = [1, '2', 3];arr1 = [1, 2, 3];let fe: string[];fe = [1, 2, 3]; // TSfe = ['Vue', 'React', 'Angular']; 不确定什么属性12345678// anylet type_con: any;type_con = [];type_con = &#123;&#125;;type_con = 1;type_con = '2';type_con = true;type_con.func(); Void123//voidlet test_void: void = null;test_void = 1; Function定义12345678910111213141516function vo(): void &#123; console.log('这是一个返回值为void的函数');&#125;function vo1(): void &#123; console.log('这是一个返回值为void的函数'); return '';&#125;function str(): string &#123; console.log('这是一个返回值为string的函数');&#125;function str1(): string &#123; console.log('这是一个返回值为string的函数'); return 'string';&#125; 当我们在使用函数的时候，有些时候会使用到函数参数默认，或者可选参数，那么在TS中如何写呢？123456function game(name: string, rank?: string, score: number = 0): string &#123; return `$&#123;name&#125; $&#123;rank&#125; $&#123;score&#125;`&#125;console.log(game('rainy', 'difficult', 10000));console.log(game('rainy', 'difficult'));console.log(game('rainy')); Class类123456789101112131415161718192021222324252627282930313233class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; greet() &#123; console.log(`Hello, $&#123;this.name&#125;`); &#125;&#125;class Student extends Person &#123; name: string; age: number; constructor(name: string, age: number) &#123; super(name); this.age = age; &#125; greet() &#123; console.log(`Hello, My name is $&#123;this.name&#125; and I'm $&#123;this.age&#125;`); &#125; study() &#123; console.log(`$&#123;this.name&#125;, you should go to study.`) &#125;&#125;let p = new Person('Rain120');console.log('p:', p.name)p.greet()let stu = new Student('Rain', 21);console.log('stu:', stu.name, stu.age);stu.greet();stu.study(); 我们在学习面向对象的语言，C++和Java时候知道类的属性和方法是有修饰符的，他们决定了外部是否能够访问类中的属性、方法，当用户为定义是，属性和方法默认都是public 属性，其中还有protected 和private 属性。当你使用private 修饰符定义成属性或者方法时，如果你需要让其他使用者使用这个属性时，你可以定义一个public 的方法，之后用户只能通过这个API接口来获取属性值或者方法的结果，例如：123456789101112class Person &#123; private name: string; constructor(name: string) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;let p = new Person('Rain120');console.log('person name:', p.name)console.log('person name:', p.getName()) 虽然这里报错了，但是编译结果却是可以的应为TS在转换成JS语言后，并没有真的将name编译成私有的属性，TypeScript的核心原则之一是对值所具有的结构进行类型检查，它的作用只是提示开发者。 protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问, 这就不详细讲解这些了，大家可以去学习下Java或者C++的类，感受一下。 接口（Interface）在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。这句话太官方了，我自己理解的就是它定义了一些你自己约定的参数类型。 工作中，我们使用到的是React+Typescript，所以，我把我日常写法拿出来。123456789101112interface SystemsProps &#123; systems: any&#125;export class Systems extends React.Component&lt;SystemsProps, any&gt; ... render() &#123; const &#123; systems &#125; = this.props return ( &lt;div&gt;&#123;systems.name&#125;&lt;/div&gt; ) &#125;&#125; 当然，从C++中学到接口也是可以继承的，例如：123456789interface Color&#123; color: string;&#125;interface Car extends Color&#123; price: number;&#125;let car = &lt;Car&gt;&#123;&#125;;car.color = "white";car.price = 10000000; 泛型在像C++和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 其实我们之前有用到泛型，只是没有说到这个概念。1let arr: Array&lt;number&gt; = [1, 2, 3, 4]; 这是一个最简答你的泛型，定义了一个number类型的数组，下面我写一个复杂点的泛型：1234567891011121314151617class Fruit &#123; name: string; price: number; constructor(name: string, price: number) &#123; this.name = name; this.price = price; &#125; sold() &#123; console.log(`$&#123;this.name&#125; sold $$&#123;this.price&#125;`) &#125;&#125;let fruit: Array&lt;Fruit&gt; = []fruit[0] = new Fruit('apple', 8)fruit[1] = new Fruit('banana', 5)fruit[2] = new Fruit('lemon', 10)console.log(fruit) 这个泛型是一个Fruit类型的数组，这个数组的子元素全是Fruit类型，当我们定义一个其他类型是，例如1fruit[3] = &#123; name: 'watermelon', price: 2 &#125; 类型推断机制12let num = 10;num = 'str'; 我们平常在使用变量赋值的时候，这样写是没有问题，但是使用TS类型检查后，它会根据用户第一次定义或者赋值的类型来推断该变量的类型，这就是TS的类型推断机制。 迭代器这里我们讲下我们常见的几种的迭代器，包括for-in, for-of，用来跟forEach对比，直接上代码，我们从代码来分析它们之间的不同1234567891011121314151617181920let arr: any = ['a','b','c'];arr.type = 'array'arr.forEach((item, index) =&gt; &#123; console.log('forEach', index, item, arr[index]);&#125;)for (let i in arr) &#123; console.log('for-in', i, arr[i]);&#125;let obj = &#123; 'a': 'I\'m a', 'b': 'I\'m b', 'c': 'I\'m c'&#125;for (let i of arr) &#123; console.log('for-of', i, obj[i]);&#125; 从结果上来看， forEach：只是常见的for循环，它不会遍历该对象的属性值；for-in：迭代的是对象的键（key）的列表，它会遍历对象的属性；for-of：迭代对象的键对应的值（value），它也不会遍历对象的属性。 模块这个地方熟悉CommonJS的都会知道export（导出）， import（导入），所以这里就不详细讲了，直接跳过 最后讲一下，tsconfig.json的配置，详见tsconfig.json1234567891011121314151617181920212223242526272829303132333435363738&#123; "compilerOptions": &#123; "moduleResolution": "node", "outDir": ./dist", // 生成的所有文件放在dist目录下 "target": "es5", // 将JavaScript代码降级到低版本ECMAScript 5 "lib": ["es6", "dom"], "rootDir": "app/", //仅用来控制输出的目录结构。 "jsx": "react", // 用于指定按照何种方式生成jsx代码，可选react和preserve。 "module": "esnext", // 用于指定模块的代码生成规则，可以使用 commonjs 、 amd 、 umd 、 system 、 es6 、 es2015 、 none 这些选项。 "declaration": false, // 是否需要生成定义文件d.ts，设置为true，则生成 "allowJs": true, // 接受JavaScript做为输入 "allowSyntheticDefaultImports": true, // 置为true时，则允许从没有默认导出的模块中默认导入(也就是不做检查)。 "inlineSourceMap": false, // 是否需要将sourceMap文件生成到js文件中，设置为true，则生成到js文件中。 "sourceMap": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 "noEmitOnError": false, // 设置为true时，如果遇到了错误，就不再输出 "emitDecoratorMetadata": false, // 设置为true，则使用元数据特性 "experimentalDecorators": true, // 设置为true，则支持ES7的装饰器特性 "noImplicitReturns": true, // 会防止你忘记在函数末尾返回值 "noImplicitThis": false, "noImplicitUseStrict": false, // 当设置为true时，编译输出时不会调用'use strict'指令（也就是不生成use strict） "noImplicitAny": false, // 如果编译器无法根据变量的用途推断出变量的类型，它就会悄悄的把变量类型默认为 any。 "noUnusedLocals": false, "baseUrl": "app", "paths": &#123; "app": ["app"] &#125; &#125;, // 包括app下的所有.ts（对应js文件）, .tsx（对应jsx文件）文件 "include": [ "app/**/*.ts", "app/**/*.tsx" ], // 忽略node_modules下所有的文件 "exclude": [ "node_modules", ... //其他要忽略的文件或者正则表达式表示 ]&#125;]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office 2016专业版激活教程]]></title>
    <url>%2F2018%2F07%2F21%2FCrack-Office%2F</url>
    <content type="text"><![CDATA[传送门：office 2016专业版激活教程 office 2016专业版激活教程 进入office激活教程中选择自己的版本进入相应的文件夹，下载相应的bat.txt 将bat.txt改为bat.cmd，默认是没有显示文件扩展名的，打开方式如下 然后右击bat.cmd，用管理员身份运行 运行ing: 运行完成： 激活完成：]]></content>
      <categories>
        <category>Office2016 激活office</category>
      </categories>
      <tags>
        <tag>Office 2016</tag>
        <tag>激活office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome DevTools调试（前后端小白必备招式）-- 第一招（设备模式+元素面板）]]></title>
    <url>%2F2018%2F07%2F04%2FChrome-Debug-01%2F</url>
    <content type="text"><![CDATA[转眼就毕业了，大家都各奔前程，同学有走读研，有走后端，有走测试，前端就我一个人了，所以肩负起那些走南闯北的同学的希望，解决他们遇到的前端Bug问题，然后发现好多同学都不会借助浏览器调试找出问题的所在，超级心累 因此留下这篇日志，为了方便我前端小白的那些同学更快解决问题。 此文只介绍Google的Chrome DevTools，其他浏览器大同小异，请自己探索。 官方链接 Chrome 开发者工具是一套内置于Google Chrome中的Web开发和调试工具，可用来对网站进行迭代、调试和分析。 打开Chrome 开发者工具 在页面元素上右键点击，选择 “检查” 使用 快捷键 Ctrl+Shift+I (Windows) 或 Cmd+Opt+I (Mac) 我就拿我的知乎主页来介绍吧，开发者工具打开之后 我们先了解一下开发者工具的面板介绍： 设备模式 当你的项目是移动适配时，你可以根据这个选项设置你的设备类型，包括IPhone6/7/X等设备 元素面板 你可以选择开发者工具中的左上角的那个Button，或者Windows下使用快捷键Shift+Ctrl+C 检查应用到元素的样式 与元素匹配的选择器的关联样式。 User Agent 样式表清晰标记，并且在网页上经常被 CSS 替换。 已被级联规则替换的规则将显示为带删除线的文本。 继承的样式将在“Inherited from ”标头下显示为一组。点击标头中的 DOM 节点可以导航到其在 DOM 树视图中的位置。 （CSS 2.1 属性表显示了哪些属性是可以继承的。） 灰色的条目不是已定义的规则，而是在运行时计算的规则。 如图示，当你在点击该Button时，鼠标在页面上选择任意元素，Element中会自动对齐到相应的位置，那么我们接着讲元素的其他操作 比如，我们想知道页面上这个提问按钮的颜色是什么，我想改变，但是不知道什么颜色好看呀，我可以在页面上边看效果，边确认自己的想法 取色器。请参阅取色器了解更多信息。 当前颜色。当前值的可视表示。 当前值。当前颜色的十六进制、RGBA 或 HSL 表示。 调色板。请参阅调色板了解更多信息。 着色和阴影选择器。 色调选择器。 不透明度选择器。 颜色值选择器。点击可以在 RGBA、HSL 和十六进制之间切换。 调色板选择器。点击可以选择不同的模板。 接下来，我们讲讲如何查找类名及其样式，并在页面上修改 比如，我们要找页面上一个叫做UserAvatar的类名，然后在页面上查看他的样式，并进行一些样式的修改 你可以实时的修改HTML元素和CSS样式，当然这些浏览器也会有相应的提示。 HTML元素右击可以修改相对应的属性值 接下来就是见名知意，大家可以自己尝试下其他的功能。 在你选择到你要查看的元素后，你可以在开发者工具中看到你选择HTML，包括类名，然后你可以看到该元素类的样式 使用 Computed 窗格检查和编辑当前元素的框模型参数，该元素是在计算后的表现（包括margin，border，padding，这里需要理解一下盒子模型）， 框模型中的所有值均可修改，只需点击它们即可。 在 Styles 窗格中，点击您修改的文件。DevTools 会将您带到 Sources 面板，很多时候你的代码都是被压缩的状态，你可以点击左下角的{}将其进行格式化 添加、启用和停用 CSS 类 我们接着来看这个提问这个Button，点击 .cls 按钮可以查看与当前选定元素关联的所有 CSS 类。 从这里，您可以执行以下操作： 启用或停用当前与元素关联的类。 向元素添加新类。 添加或移除动态样式（伪类） 有的时候，我们需要查看一些伪类或者动态元素样式在触发之后的状态，例如a标签hover之后的状态,例如，我们将页面中&lt;a class=&quot;AppHeader-navItem&quot; href=&quot;//www.zhihu.com/&quot;&gt;首页&lt;/a&gt;在触发hover之后的颜色和字体更改为color:red;font-size:20px; 从图示可知，我们在选择hover之后，之前灰色的样式变成正常转态，也就是这部分样式生效了，或者右击该元素选择进行下列操作也可以实现 Styles 窗格提供了一个用于向样式规则添加 color 和 background-color 声明的快捷方式。样式规则的右下角有一个由三个点组成的图标。您需要将鼠标悬停到样式规则上才能看到这个图标。这5个图标可以通过提示得知它们的作用 第一招，关于设备模式以及元素面板的招式，基本上已经学完了，大家可以尝试一下，我们第二招再见]]></content>
      <categories>
        <category>Chrome DevTools</category>
      </categories>
      <tags>
        <tag>前端调试技巧</tag>
        <tag>Chrome DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery + dataTable + Bootstrap + 完整逻辑实现表格的增删改查]]></title>
    <url>%2F2018%2F07%2F03%2FdataTable%2F</url>
    <content type="text"><![CDATA[最近在做毕设，同学在做前端页面的时候使用到JQuery、DataTable和Bootstrap这些控件，然后自己又在刷题的时候遇到一个这个demo的实现，于是就自己去官网文档上学习了一下，尝试实现这个demo 官方文档：DataTable Demo代码：Demo代码 效果如下图示： 顶部button DOM结构：123456789101112// 页面上的三个button，增删改&lt;div class="btn-group operation"&gt; &lt;button id="btn_add" type="button" class="btn bg-primary"&gt; &lt;span class="glyphicon glyphicon-plus" aria-hidden="true"&gt;&lt;/span&gt;新增 &lt;/button&gt; &lt;button id="btn_edit" type="button" class="btn bg-info"&gt; &lt;span class="glyphicon glyphicon-pencil" aria-hidden="true"&gt;&lt;/span&gt;修改 &lt;/button&gt; &lt;button id="btn_delete" type="button" class="btn btn-success"&gt; &lt;span class="glyphicon glyphicon-remove" aria-hidden="true"&gt;&lt;/span&gt;删除 &lt;/button&gt;&lt;/div&gt; 这里的Modal框的实现是借助Bootstrap模态框来实现的 添加图书 Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="addBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;添加图书&lt;/h4&gt; &lt;/div&gt; &lt;div id="addBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="bookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="bookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="bookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelAdd" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="addBooksInfo" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 修改图书内容Modal框的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="modal fade" id="editBookInfo" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;修改图书内容&lt;/h4&gt; &lt;/div&gt; &lt;div id="editBookModal" class="modal-body"&gt; &lt;div class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="editBookName" class="col-sm-2 control-label"&gt;书名:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookName" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookAuthor" class="col-sm-2 control-label"&gt;作者:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookAuthor" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPrice" class="col-sm-2 control-label"&gt;价格:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPrice" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookPublish" class="col-sm-2 control-label"&gt;出版社:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookPublish" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="editBookISBN" class="col-sm-2 control-label"&gt;ISBN:*&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control" id="editBookISBN" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;div class="center-block"&gt; &lt;button id="cancelEdit" type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="saveEdit" type="button" class="btn btn-success" data-dismiss="modal"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 删除Modal框的实现：1234567891011121314&lt;div class="modal fade" id="deleteBook" role="dialog"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title"&gt;确认要删除吗？&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button id="delete" type="button" class="btn btn-danger" data-dismiss="modal"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 表格的实现：12345678910111213&lt;table id="books" class="table table-striped table-bordered row-border hover order-column" cellspacing="0" width="100%"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;ISBN&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 使用到一些简单的自定义样式：12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .content &#123; margin: 50px auto; border: 1px solid #ccc; &#125; .operation &#123; margin: 10px; &#125; .operation &gt; button &#123; margin: 10px; &#125; #books_length &#123; float: left; margin-left: 20px; &#125; #books_filter &#123; float: right; margin-right: 20px; &#125; #books &#123; margin: 5px; &#125; .center-block &#123; display: block; width: 21%; margin: auto; &#125;&lt;/style&gt; 其中，dataTable有三种数据获取方式，数组，JSON和Ajax请求数据例如数组数据：1var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] 其实官网很多小例子，大家可以参考学习dataTables中文网 以上都是页面的DOM结构的实现，接下来，我们讲讲JS代码实现逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;script&gt; var data = [['', '三体', '刘慈欣', '39.00', '重庆出版社', '982513213516']] var titles = ['书名', '作者', '价格', '出版社', 'ISBN'] $(function () &#123; var table = $('#books').DataTable(&#123; data: data, "pagingType": "full_numbers", "bSort": true, // 国际化 "language": &#123; "sProcessing": "处理中...", "sLengthMenu": "显示 _MENU_ 项结果", "sZeroRecords": "没有匹配结果", "sInfo": "显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项", "sInfoEmpty": "显示第 0 至 0 项结果，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": &#123; "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页" &#125;, // 排序方式 "oAria": &#123; "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" &#125; &#125;, "columnDefs": [&#123; "searchable": false, "orderable": true, "targets": 0 &#125;], "order": [[1, 'asc']] &#125;); table.on('order.dt search.dt', function() &#123; table.column(0, &#123; search: 'applied', order: 'applied' &#125;).nodes().each(function(cell, i) &#123; cell.innerHTML = i + 1; &#125;); &#125;).draw(); $('#books tbody').on('click', 'tr', function () &#123; if ( $(this).hasClass('selected') ) &#123; $(this).removeClass('selected'); &#125; else &#123; table.$('tr.selected').removeClass('selected'); $(this).addClass('selected'); &#125; &#125;); // 取消添加 $("#cancelAdd").on('click', function() &#123; console.log('cancelAdd'); $("#addBookModal").find('input').val('') &#125;) // 添加图书信息 $("#addBooksInfo").on('click', function() &#123; console.log('addBooksInfo'); if (data.length) &#123; if ($("#addBookModal").find('input').val() !== '') &#123; var bookName = $("#bookName").val() var bookAuthor = $("#bookAuthor").val() var bookPrice = $("#bookPrice").val() var bookPublish = $("#bookPublish").val() var bookISBN = $("#bookISBN").val() var addBookInfos = [].concat(bookName, bookAuthor, bookPrice, bookPublish, bookISBN); for (var i = 0; i &lt; addBookInfos.length; i++) &#123; if (addBookInfos[i] === '') &#123; alert(titles[i] + '内容不能为空') &#125; &#125; table.row.add(['', bookName, bookAuthor, bookPrice, bookPublish, bookISBN]).draw(); $("#addBookModal").find('input').val('') &#125; &#125; else &#123; alert('请输入内容') &#125; &#125;) $("#addBooksInfo").click(); $("#btn_add").click(function()&#123; console.log('add'); $("#addBook").modal() &#125;); // 编辑图书 $('#btn_edit').click(function () &#123; console.log('edit'); if (table.rows('.selected').data().length) &#123; $("#editBookInfo").modal() var rowData = table.rows('.selected').data()[0]; var inputs = $("#editBookModal").find('input') for (var i = 0; i &lt; inputs.length; i++) &#123; $(inputs[i]).val(rowData[i + 1]) &#125; &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 保存编辑 $("#saveEdit").click(function() &#123; var editBookName = $("#editBookName").val() var editBookAuthor = $("#editBookAuthor").val() var editBookPrice = $("#editBookPrice").val() var editBookPublish = $("#editBookPublish").val() var editBookISBN = $("#editBookISBN").val() var newRowData = [].concat(editBookName, editBookAuthor, editBookPrice, editBookPublish, editBookISBN); var tds = Array.prototype.slice.call($('.selected td')) for (var i = 0; i &lt; newRowData.length; i++) &#123; if (newRowData[i] !== '') &#123; tds[i + 1].innerHTML = newRowData[i]; &#125; else &#123; alert(titles[i] + '内容不能为空') &#125; &#125; &#125;) // 取消保存 $("#cancelEdit").click(function() &#123; console.log('cancelAdd'); $("#editBookModal").find('input').val('') &#125;) // 删除项目 $('#btn_delete').click(function () &#123; if (table.rows('.selected').data().length) &#123; $("#deleteBook").modal() &#125; else &#123; alert('请选择项目'); &#125; &#125;); // 删除 $('#delete').click(function () &#123; table.row('.selected').remove().draw(false); &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>dataTable</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>Bootstrap</tag>
        <tag>dataTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐横向菜单的实现]]></title>
    <url>%2F2018%2F06%2F30%2Fhorizontal-menu%2F</url>
    <content type="text"><![CDATA[之前在学习的时候有稍微捣鼓一下网易云音乐，主要是为了学习Vue，巩固基础知识，然后看到这个横向菜单，当然个人也喜欢看球，所以每次看腾讯NBA的时候总是会想这个是这样实现的，于是借助之前还没写完的demo，完成这个横向菜单的实现，废话不多说，先上效果图 从使用虎牙直播横向菜单的体验得到，我们的横向菜单的业务逻辑如下： 滑动菜单，并选择菜单项； 选择某个菜单项，该菜单项居中（去除边界菜单项） 我们的使用的better-scroll这个插件来实现，具体安装请参考BetterScroll 前端DOM结构12345678910111213&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 通过使用插件Vue来调试项目 其中tabs包括菜单项名和它的路由1234567891011121314151617181920212223242526272829303132333435data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, // tab移动的距离 tabWidth: 80 // 每个tab的宽度 &#125; 样式12345678910111213141516171819202122232425.mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box 样式和DOM结构就不详细讲了，具体讲实现吧首先需要计算出这个菜单中所有内容的width，也就是包裹这个菜单的容器；接着初始化better-scroll，并忽略该实例对象的垂直方向的滑动.1234567891011121314151617methods: &#123; _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' // 忽略这个实例对象的垂直滑动事件 &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125; 这里是第二个业务逻辑的思路（应该会有更好的思路，求大佬指点） 我的思路是这样的：每一个菜单项都会有各自的点击移动操作，所以我是根据当前tabs的位置，通过点击事件将tabs移动到它相应的位置，例如，中间菜单项在点击时会移动到居中的位置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125; &#125; 很多时候我们在使用better-scroll的时候，发现这个实例对象已经初始化，但是不能滑动，是因为，Vue是异步更新数据的，所以我们需要异步计算它实际内容的宽度或者高度，Vue提供一个了this.$nextTick()这个hock来实现，这个API是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 官方解释：$nextTick 当生命钩子mounted触发时，初始化better-scroll12345mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;)&#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div class="mv-tabs"&gt; &lt;div class="tabs" ref="tabsWrapper"&gt; &lt;ul ref="tab"&gt; &lt;li v-for="(item, index) in tabs" :key="index" @click="selectItem(index)"&gt; &lt;router-link tag="div" :to="item.to" class="tab-item"&gt; &lt;span class="tab-link"&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from 'better-scroll'export default &#123; data () &#123; return &#123; tabs: [ &#123; to: '/mv/recommend-mv', title: '推荐' &#125;, &#123; to: '/mv/music-mv', title: '音乐' &#125;, &#123; to: 'show-mv', title: 'Show' &#125;, &#123; to: '/mv/acg-mv', title: '二次元' &#125;, &#123; to: '/mv/dance-mv', title: '舞蹈' &#125;, &#123; to: '/mv/game-mv', title: '游戏' &#125;, &#123; to: '/mv/mvs', title: 'mv' &#125; ], mX: 0, tabWidth: 80 &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this._initMenu() &#125;) &#125;, methods: &#123; selectItem (index) &#123; let tabs = this.$refs.tab let moveX = +tabs.style.transform.replace(/[^0-9\-,]/g, '').split(',')[0] switch (index) &#123; case 0: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth) &#123; this.mX = 0 &#125; break case 1: if (moveX &lt;= 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 2: if (moveX &lt; 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = 0 &#125; break case 3: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth &#125; break case 4: if (moveX &lt;= 0 &amp;&amp; moveX &gt;= -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; else if (moveX === 0) &#123; this.mX = -this.tabWidth * 2 &#125; break case 5: if (moveX &lt; 0 &amp;&amp; moveX &gt; -this.tabWidth * 2) &#123; this.mX = -this.tabWidth * 2 &#125; break case 6: if (moveX &gt; -this.tabWidth * 2 &amp;&amp; moveX &lt; -this.tabWidth * 3 / 2) &#123; this.mX = -this.tabWidth * 2 + 10 &#125; break default: break &#125; tabs.style.transform = `translate($&#123;this.mX&#125;px, 0)` &#125;, _initMenu () &#123; let tabsWidth = this.tabWidth let width = this.tabs.length * tabsWidth this.$refs.tab.style.width = `$&#123;width&#125;px` this.$nextTick(() =&gt; &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.tabsWrapper, &#123; scrollX: true, eventPassthrough: 'vertical' &#125;) &#125; else &#123; this.scroll.refresh() &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .mv-tabs position relative top -5.5rem bottom 0 width 100% .tabs margin-top 3rem height 2.5rem width 100% line-height 2.5rem box-sizing border-box overflow hidden white-space nowrap .tab-item float left width 80px height 40px text-align center .tab-link padding-bottom 5px color #333333 &amp;.router-link-active color #d33a31 border-bottom 2px solid #d33a31 box-sizing border-box&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>better-scroll</tag>
        <tag>网易云音乐</tag>
        <tag>横向菜单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之网易云音乐PC版轮播图的实现]]></title>
    <url>%2F2018%2F06%2F25%2Fnetease-slider%2F</url>
    <content type="text"><![CDATA[最近在刷网易云音乐歌单时发现首页的轮播图很有意思，正好自己想尝试做一个PC版的网易云音乐，于是就是使用Vue去做这个demo，废话少说，我要出招了，接招吧 页面的DOM结构123456789101112131415161718192021&lt;template&gt; &lt;div class="slider-container" ref='slider' :style="sliderStyle" @mouseover="pause()" @mouseout="play()"&gt; &lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Slider-container的样式(Stylus)123456.slider-container width: 100% height: 100% text-align: center padding: 10px 0 position: relative 这个子组件主要分为两块。 轮播图，其中它们的业务逻辑是 自动切换 左右icon切换轮播图 点击前后轮播图切换轮播图 鼠标滑动到轮播图停止轮播，离开后继续轮播 Slider-content的DOM结构123456789&lt;div class="slider-content" :class="mask ? 'mask' : ''"&gt; &lt;div class="slider" v-for="(item, index) in list" :key="index" :class="setClass(index)" @click="onClick(index)" :style="setBGImg(item.src)"&gt; &lt;/div&gt; &lt;i v-show="arrow" class="iconfont icon-left" @click="prev()"&gt;&lt;/i&gt; &lt;i v-show="arrow" class="iconfont icon-right" @click="next()"&gt;&lt;/i&gt;&lt;/div&gt; Slider-content的样式(Stylus)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.slider-content position: relative width: 100% height: calc(100% - 20px) left: 0% top: 0% margin: 0px padding: 0px background-size: inherit .slider position: absolute margin: 0 padding: 0 top: 0 left: 50% width: 65% height: 100% transition: 500ms all ease-in-out background-color: #fff background-repeat: no-repeat background-position: center background-size: inherit transform: translate3d(-50%,0,-80px) z-index: 1 &amp;:before position: absolute content: "" width: 100% height: 100% top: 0 left: 0 background-color: rgba(0, 0, 0, 0) transition-delay: 100ms!important transition: all 500ms cursor: pointer &amp;.active transform: translate3d(-50%, 0, 0) z-index: 20 &amp;.prev transform: translate3d(-75%, 0, -100px) z-index: 19 &amp;.next transform: translate3d(-25%, 0, -100px) z-index: 18 i width: 17.5% display: none position: absolute top: 40% font-size: 22px color: rgba(255, 255, 255, 0.5) text-shadow: 0 0 24px rgba(0, 0, 0, 0.3) cursor: pointer z-index: 21 &amp;:first-child left: 0 &amp;:last-child right: 0 &amp;:hover i color: rgba(255, 255, 255, 0.8) display: block &amp;.mask .slider &amp;.prev, &amp;.next &amp;:before background-color: rgba(0, 0, 0, 0.50) 底部的dot， 其中它们的业务逻辑是 当前轮播图对应位置的dot高亮 鼠标移动到相应的dot上切换对应位置的轮播图 Dots的DOM结构12345&lt;div class="dots" v-if="dots"&gt; &lt;span v-for="(item, index) in list" :key="index" :style="setActiveDot(index)" @mouseover="currentIndex = index"&gt;&lt;/span&gt;&lt;/div&gt; Dots的样式(Stylus)123456789.dots width: 100% height: 20px span display: inline-block width: 20px height: 2px margin: 1px 3px cursor: pointer 上面是页面的DOM结构和表现的实现代码，接下来我们要讲的是连招的实现，小心啦，我要摸眼W + R3了。上面我们讲到轮播图的业务逻辑，接下来，我们就讲讲如何实现的的吧 自动轮播12345678play () &#123; this.pause(); if (this.autoPlay) &#123; this.timer = setInterval(()=&gt;&#123; this.next(); &#125;, this.interval) &#125;&#125; 暂停轮播123pause () &#123; clearInterval(this.timer);&#125; Icon切换轮播图123456next () &#123; this.currentIndex = ++this.currentIndex % this.list.length;&#125;,prev () &#123; this.currentIndex = this.currentIndex === 0 ? this.list.length - 1 : this.currentIndex - 1;&#125;, 前后轮播图的切换轮播图12345678910111213onClick (i) &#123; if (i === this.currentIndex)&#123; this.$emit('sliderClick', i); &#125; else &#123; let currentClickClassName = this.sliderDomList[i].className.split(' ')[1] console.log(currentClickClassName) if (currentClickClassName === 'next') &#123; this.next() &#125; else &#123; this.prev() &#125; &#125;&#125; dots轮播图的切换轮播图这里比较简单，只需要设置它的鼠标事件即可1@mouseover="currentIndex = index" 到这里，基本上我们提出的业务逻辑原理都已经实现了，到时候我会将代码整理完了commit到github上，现在正在整理ing，谢谢。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>better-scroll</tag>
        <tag>网易云音乐</tag>
        <tag>轮播图</tag>
      </tags>
  </entry>
</search>
